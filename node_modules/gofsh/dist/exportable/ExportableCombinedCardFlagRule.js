"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportableCombinedCardFlagRule = void 0;
const _1 = require(".");
const fsh_sushi_1 = require("fsh-sushi");
const lodash_1 = require("lodash");
// NOTE: This needs to extend a SUSHI SdRule (in this case fshrules.CardRule) because
// ExportableProfile.rules (which allows ExportableCombinedCardFlagRule) must be assignable to
// Profile.rules in order for TypeScript to recognize it as a proper subclass of Profile.
class ExportableCombinedCardFlagRule extends fsh_sushi_1.fshrules.CardRule {
    constructor(path, cardRule, 
    // GoFSH only creates 1 flag rule per path (even though human authors can create > 1)
    flagRule) {
        super(path);
        this.cardRule = cardRule;
        this.flagRule = flagRule;
        this.indent = 0;
    }
    // Redirect all min/max accessors to cardRule.min/cardRule.max
    get min() {
        return this.cardRule.min;
    }
    set min(n) {
        this.cardRule.min = n;
    }
    get max() {
        return this.cardRule.max;
    }
    set max(n) {
        this.cardRule.max = n;
    }
    toFSH() {
        return `${lodash_1.repeat(' ', _1.INDENT_SIZE * this.indent)}* ${this.path} ${this.cardRule.cardToString()} ${this.flagRule.flagsToString()}`;
    }
}
exports.ExportableCombinedCardFlagRule = ExportableCombinedCardFlagRule;
//# sourceMappingURL=ExportableCombinedCardFlagRule.js.map