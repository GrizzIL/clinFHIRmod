"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadOptimizers = void 0;
const path_1 = __importDefault(require("path"));
const toposort_1 = __importDefault(require("toposort"));
const GoFSHLogger_1 = require("../utils/GoFSHLogger");
/**
 * Dynamically load the optimizer plugins and return them in the order they should be executed.
 * If there is a circular dependency in the plugins, an error will be logged and the resulting order is undetermined.
 * @param folder - the folder to load optimizers from.  Currently only used in tests.  CLI uses default value.
 */
function loadOptimizers(folder = path_1.default.join(__dirname, 'plugins')) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // make an import-friendly relative path (e.g. \Users\bob\dev\optimizers --> ../../../../dev/optimizers)
        let relativePath = path_1.default.relative(__dirname, folder);
        if (path_1.default.sep === '\\') {
            relativePath = relativePath.replace(/\\/g, '/');
        }
        if (!relativePath.startsWith('.')) {
            relativePath = `./${relativePath}`;
        }
        // Import optimizers from the specified folder
        // relativePath is placed in a dynamic string to allow for FSHOnline compatibility
        const Optimizers = yield Promise.resolve().then(() => __importStar(require(`${relativePath}`)));
        const optimizers = Object.values(Optimizers).filter(
        // Remove non-optimizers
        o => typeof (o === null || o === void 0 ? void 0 : o.name) === 'string' &&
            typeof (o === null || o === void 0 ? void 0 : o.description) === 'string' &&
            typeof (o === null || o === void 0 ? void 0 : o.optimize) === 'function');
        GoFSHLogger_1.logger.debug(`Loaded ${optimizers.length} optimizers from ${path_1.default.join(__dirname, 'plugins')}`);
        // Sort them using a topological sort to get them in dependency order
        // See: https://www.npmjs.com/package/toposort#sorting-dependencies
        const nodes = [];
        const edges = [];
        optimizers.forEach(opt => {
            var _a, _b;
            nodes.push(opt.name);
            (_a = opt.runAfter) === null || _a === void 0 ? void 0 : _a.forEach(dependsOn => {
                const preceedingOptimizers = optimizers.filter(o => o.name !== opt.name && dependsOn instanceof RegExp
                    ? dependsOn.test(o.name)
                    : dependsOn === o.name);
                if (preceedingOptimizers.length > 0) {
                    preceedingOptimizers.forEach(preceedingOptimizer => {
                        edges.push([opt.name, preceedingOptimizer.name]);
                    });
                }
                else {
                    GoFSHLogger_1.logger.error(`The ${opt.name} optimizer specifies an unknown optimizer in runAfter: ${dependsOn}`);
                }
            });
            (_b = opt.runBefore) === null || _b === void 0 ? void 0 : _b.forEach(dependedOnBy => {
                const succeedingOptimizers = optimizers.filter(o => o.name !== opt.name && dependedOnBy instanceof RegExp
                    ? dependedOnBy.test(o.name)
                    : dependedOnBy === o.name);
                if (succeedingOptimizers.length > 0) {
                    succeedingOptimizers.forEach(succeedingOptimizer => {
                        edges.push([succeedingOptimizer.name, opt.name]);
                    });
                }
                else {
                    GoFSHLogger_1.logger.error(`The ${opt.name} optimizer specifies an unknown optimizer in runBefore: ${dependedOnBy}`);
                }
            });
        });
        let ordered;
        try {
            ordered = toposort_1.default.array(nodes, edges).reverse();
        }
        catch (e) {
            // This message should be reliably present and reliably in this format, but use '?' defensively just in case
            const nodeMatch = (_a = e.message) === null || _a === void 0 ? void 0 : _a.match(/"([^"]+)"$/);
            GoFSHLogger_1.logger.error(`Could not determine order of optimizers; cyclic dependency involving ${nodeMatch === null || nodeMatch === void 0 ? void 0 : nodeMatch[1]}. Optimization may be affected.`);
            // just return the original order
            ordered = nodes;
        }
        // ordered is the list of names, so map it back to the optimizers
        return ordered.map(name => optimizers.find(opt => opt.name === name));
    });
}
exports.loadOptimizers = loadOptimizers;
//# sourceMappingURL=loadOptimizers.js.map