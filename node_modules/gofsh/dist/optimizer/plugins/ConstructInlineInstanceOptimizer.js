"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const exportable_1 = require("../../exportable");
const RemoveGeneratedTextRulesOptimizer_1 = require("./RemoveGeneratedTextRulesOptimizer");
const RemoveGeneratedTextRulesOptimizer_2 = __importDefault(require("./RemoveGeneratedTextRulesOptimizer"));
const ResolveInstanceOfURLsOptimizer_1 = __importDefault(require("./ResolveInstanceOfURLsOptimizer"));
const AddReferenceKeywordOptimizer_1 = __importDefault(require("./AddReferenceKeywordOptimizer"));
const utils_1 = require("../../utils");
const fsh_sushi_1 = require("fsh-sushi");
exports.default = {
    name: 'construct_inline_instance',
    description: 'Construct inline instances from groups of rules in a contained resource or a Bundle',
    runBefore: [
        RemoveGeneratedTextRulesOptimizer_2.default.name,
        ResolveInstanceOfURLsOptimizer_1.default.name,
        AddReferenceKeywordOptimizer_1.default.name
    ],
    optimize(pkg, fisher, options = {}) {
        const inlineInstances = [];
        [...pkg.instances, ...pkg.profiles, ...pkg.extensions].forEach(resource => {
            const ruleType = resource instanceof exportable_1.ExportableInstance
                ? exportable_1.ExportableAssignmentRule
                : exportable_1.ExportableCaretValueRule;
            // First get all possible paths for which child elements should be extracted onto an inline instance
            const basePaths = resource.rules
                .filter(rule => rule instanceof ruleType &&
                (/^contained(\[\d+\])?\.resourceType$/.test(getRulePath(rule)) ||
                    /^entry(\[\d+\])?\.resource\.resourceType$/.test(getRulePath(rule))))
                .map(rule => getRulePath(rule).replace('.resourceType', ''));
            let generatedIdCount = 0;
            // For each base path, extract an inline instance
            basePaths.forEach(basePath => {
                const rulesToRemove = [];
                let id;
                let resourceType;
                const profileIndices = [];
                const inlineInstanceRules = [];
                // Find all rules on the instance that are children of the base path and should be
                // added to the inline instance
                resource.rules.forEach((rule, i) => {
                    if (!(rule instanceof ruleType && getRulePath(rule).startsWith(basePath))) {
                        return;
                    }
                    rulesToRemove.push(i);
                    if (rule instanceof exportable_1.ExportableCaretValueRule) {
                        const newRule = new exportable_1.ExportableAssignmentRule(rule.caretPath);
                        newRule.value = rule.value;
                        rule = newRule;
                    }
                    // id and resourceType and meta.profile should be used for keywords, all other rules are added
                    if (rule.path === `${basePath}.id` &&
                        isNaN(parseInt(rule.value)) &&
                        ![...pkg.instances, ...inlineInstances].find(instance => instance.id === rule.value)) {
                        id = rule.value;
                    }
                    else if (rule.path === `${basePath}.resourceType`) {
                        resourceType = rule.value;
                    }
                    else {
                        const inlineInstanceRule = lodash_1.cloneDeep(rule);
                        inlineInstanceRule.path = rule.path.replace(`${basePath}.`, '');
                        // if this rule is on meta.profile, save its index to check later
                        if (/^meta\.profile(\[\d+\])?$/.test(inlineInstanceRule.path)) {
                            profileIndices.push(inlineInstanceRules.length);
                        }
                        inlineInstanceRules.push(inlineInstanceRule);
                    }
                });
                let newInstance = new exportable_1.ExportableInstance(id !== null && id !== void 0 ? id : `Inline-Instance-for-${resource.id}-${++generatedIdCount}`);
                // if a profile is available and the user wants it, try to fish it up and use it as InstanceOf
                if ((profileIndices.length === 1 && options.metaProfile !== 'none') ||
                    (profileIndices.length > 0 && options.metaProfile === 'first')) {
                    const profileToTry = inlineInstanceRules[profileIndices[0]].value;
                    const instanceOfJSON = fisher.fishForFHIR(profileToTry, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Profile, fsh_sushi_1.utils.Type.Extension, fsh_sushi_1.utils.Type.Type);
                    if (instanceOfJSON == null) {
                        newInstance.instanceOf = resourceType;
                        utils_1.logger.warn(`InstanceOf definition not found for ${newInstance.id}. The ResourceType of the instance will be used as a base.`);
                    }
                    else {
                        newInstance.instanceOf = profileToTry;
                        // since we are going to remove meta.profile[0], decrement the indices on other meta.profile[i] rules
                        profileIndices.slice(1).forEach(idx => {
                            const profileRule = inlineInstanceRules[idx];
                            const profileIndex = profileRule.path.match(/^meta\.profile\[(\d+)\]$/)[1];
                            profileRule.path = `meta.profile[${parseInt(profileIndex, 10) - 1}]`;
                        });
                        // remove the rule on meta.profile[0]
                        inlineInstanceRules.splice(profileIndices[0], 1);
                    }
                }
                else {
                    newInstance.instanceOf = resourceType;
                }
                newInstance.rules.push(...inlineInstanceRules);
                newInstance.usage = 'Inline';
                const duplicatedInstance = duplicatesExistingInstance(newInstance, [
                    ...inlineInstances,
                    ...pkg.instances
                ]);
                if (duplicatedInstance) {
                    newInstance = duplicatedInstance;
                }
                else {
                    inlineInstances.push(newInstance);
                }
                lodash_1.pullAt(resource.rules, rulesToRemove);
                if (resource instanceof exportable_1.ExportableInstance) {
                    const inlineInstanceRule = new exportable_1.ExportableAssignmentRule(basePath);
                    inlineInstanceRule.isInstance = true;
                    inlineInstanceRule.value = newInstance.id;
                    resource.rules.splice(rulesToRemove[0], 0, inlineInstanceRule);
                }
                else {
                    const inlineInstanceRule = new exportable_1.ExportableCaretValueRule('');
                    inlineInstanceRule.caretPath = basePath;
                    inlineInstanceRule.isInstance = true;
                    inlineInstanceRule.value = newInstance.id;
                    resource.rules.splice(rulesToRemove[0], 0, inlineInstanceRule);
                }
            });
        });
        pkg.instances.push(...inlineInstances);
    }
};
function getRulePath(rule) {
    return rule instanceof exportable_1.ExportableCaretValueRule ? rule.caretPath : rule.path;
}
function duplicatesExistingInstance(instance, existingInstances) {
    var _a, _b, _c;
    const instanceId = (_b = (_a = instance.rules.find(rule => rule.path === 'id')) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : instance.id;
    const duplicatedInstance = existingInstances.find(i => i.id === instanceId && i.instanceOf === instance.instanceOf);
    // We need to ignore generated text rules, since these will be later removed anyway, and will not match
    // between an instance and the inline version of that instance
    const instanceHasGeneratedText = RemoveGeneratedTextRulesOptimizer_1.hasGeneratedText(instance);
    const duplicatedInstanceHasGeneratedText = duplicatedInstance != null && RemoveGeneratedTextRulesOptimizer_1.hasGeneratedText(duplicatedInstance);
    if (lodash_1.isEqual(instance.rules.filter(rule => rule.path !== 'id' && !(instanceHasGeneratedText && rule.path.match(/^text\./))), (_c = duplicatedInstance === null || duplicatedInstance === void 0 ? void 0 : duplicatedInstance.rules) === null || _c === void 0 ? void 0 : _c.filter(rule => !(duplicatedInstanceHasGeneratedText && rule.path.match(/^text\./))))) {
        return duplicatedInstance;
    }
}
//# sourceMappingURL=ConstructInlineInstanceOptimizer.js.map