"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const exportable_1 = require("../../exportable");
const ResolveOnlyRuleURLsOptimizer_1 = __importDefault(require("./ResolveOnlyRuleURLsOptimizer"));
const lodash_1 = require("lodash");
exports.default = {
    name: 'construct_named_extension_contains_rules',
    description: 'Convert "extension contains" rules to use named extensions where appropriate',
    runAfter: [ResolveOnlyRuleURLsOptimizer_1.default.name],
    optimize(pkg) {
        [...pkg.profiles, ...pkg.extensions].forEach(sd => {
            const rulesToRemove = [];
            sd.rules.forEach(rule => {
                if (rule instanceof exportable_1.ExportableContainsRule && rule.path.endsWith('extension')) {
                    rule.items.forEach(item => {
                        const onlyRuleIdx = sd.rules.findIndex(other => other.path === `${rule.path}[${item.name}]` && other instanceof exportable_1.ExportableOnlyRule);
                        const onlyRule = sd.rules[onlyRuleIdx];
                        // Explicitly ignore "Extension" since some IGs (ex: USCore) add a type constraint to Extension
                        // on the differential unnecessarily. Using the "named" syntax with "Extension" causes errors in SUSHI.
                        // As long as the type is not "Extension", we assume it is a profile of Extension, and we can therefore
                        // use the "named" syntax.
                        if ((onlyRule === null || onlyRule === void 0 ? void 0 : onlyRule.types.length) === 1 && (onlyRule === null || onlyRule === void 0 ? void 0 : onlyRule.types[0].type) !== 'Extension') {
                            item.type = onlyRule.types[0].type;
                            rulesToRemove.push(onlyRuleIdx);
                        }
                    });
                }
            });
            lodash_1.pullAt(sd.rules, rulesToRemove);
        });
    }
};
//# sourceMappingURL=ConstructNamedExtensionContainsRulesOptimizer.js.map