"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fsh_sushi_1 = require("fsh-sushi");
const exportable_1 = require("../../exportable");
const common_1 = require("fsh-sushi/dist/fhirtypes/common");
const lodash_1 = require("lodash");
const SimplifyInstanceNameOptimizer_1 = __importDefault(require("./SimplifyInstanceNameOptimizer"));
exports.default = {
    name: 'add_reference_keyword_optimizer',
    description: 'Adds the "Reference" keyword to instances where applicable',
    runAfter: [SimplifyInstanceNameOptimizer_1.default.name],
    optimize(pkg, fisher) {
        pkg.instances.forEach(instance => {
            const rulesToRemove = [];
            let sd;
            instance.rules
                .filter(rule => rule instanceof exportable_1.ExportableAssignmentRule)
                .forEach((rule, i) => {
                var _a, _b, _c;
                // Since looking up the type takes some time, only do it when it is plausible
                // that the type of the element is Reference
                if (rule.path.endsWith('reference') && typeof rule.value === 'string') {
                    sd = sd !== null && sd !== void 0 ? sd : fisher.fishForStructureDefinition(instance.instanceOf);
                    // We search for the path of the parent, without numerical indices, since
                    // findElementByPath does not handle numerical indices
                    const parentPath = common_1.splitOnPathPeriods(rule.path).slice(0, -1).join('.');
                    const searchablePath = parentPath.replace(/\[\d+\]/g, '');
                    if (((_c = (_b = (_a = sd === null || sd === void 0 ? void 0 : sd.findElementByPath(searchablePath, fisher)) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.code) === 'Reference') {
                        // Remove '#' prefix from references to contained resources (if applicable)
                        const referenceTarget = rule.value.replace(/^#/, '');
                        const reference = new fsh_sushi_1.fshtypes.FshReference(referenceTarget);
                        // If we are converting the reference, look for a matching display rule, using the
                        // original numerical parent path
                        const matchingDisplayRuleIndex = instance.rules
                            .filter(rule => rule instanceof exportable_1.ExportableAssignmentRule)
                            .findIndex(otherRule => otherRule.path === `${parentPath}.display`);
                        if (matchingDisplayRuleIndex >= 0) {
                            rulesToRemove.push(matchingDisplayRuleIndex);
                            reference.display = instance.rules[matchingDisplayRuleIndex].value;
                        }
                        const newReferenceRule = new exportable_1.ExportableAssignmentRule(parentPath);
                        newReferenceRule.value = reference;
                        instance.rules[i] = newReferenceRule;
                    }
                }
            });
            lodash_1.pullAt(instance.rules, rulesToRemove);
        });
    }
};
//# sourceMappingURL=AddReferenceKeywordOptimizer.js.map