"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const SimplifyArrayIndexingOptimizer_1 = __importDefault(require("./SimplifyArrayIndexingOptimizer"));
const SimplifyObeysRuleDotPathsOptimizer_1 = __importDefault(require("./SimplifyObeysRuleDotPathsOptimizer"));
const exportable_1 = require("../../exportable");
exports.default = {
    name: 'simplify_rule_path_contexts',
    description: 'Make rule paths shorter by indenting the rule and using the context of preceding rules.',
    runAfter: [SimplifyArrayIndexingOptimizer_1.default.name, SimplifyObeysRuleDotPathsOptimizer_1.default.name],
    optimize(pkg) {
        [
            ...pkg.profiles,
            ...pkg.extensions,
            ...pkg.logicals,
            ...pkg.resources,
            ...pkg.instances,
            ...pkg.codeSystems
        ].forEach(entity => {
            if (entity instanceof exportable_1.ExportableCodeSystem) {
                entity.rules.forEach(rule => {
                    if (rule instanceof exportable_1.ExportableConceptRule) {
                        rule.indent = rule.hierarchy.length;
                        if (rule.indent > 0) {
                            rule.hierarchy = [];
                        }
                    }
                    else if (rule instanceof exportable_1.ExportableCaretValueRule && rule.isCodeCaretRule) {
                        rule.indent = rule.pathArray.length;
                        if (rule.indent > 0) {
                            rule.pathArray = [];
                        }
                    }
                });
            }
            else {
                const pathContext = [];
                let contextIndex;
                entity.rules.forEach(rule => {
                    let rulePathParts;
                    if (rule.path === '') {
                        rulePathParts = [];
                    }
                    else if (rule.path === '.') {
                        rulePathParts = ['.'];
                    }
                    else {
                        rulePathParts = rule.path.split('.');
                    }
                    // check if we can use an existing context
                    // check contexts at the end first so we use as deep a context as possible
                    for (contextIndex = pathContext.length - 1; contextIndex >= 0; contextIndex--) {
                        let contextPathParts;
                        if (pathContext[contextIndex] === '') {
                            // we never want to count an empty path as a match.
                            continue;
                        }
                        else if (pathContext[contextIndex] === '.') {
                            contextPathParts = ['.'];
                        }
                        else {
                            contextPathParts = pathContext[contextIndex].split('.');
                        }
                        if (contextPathParts.every((contextPart, idx) => contextPart === rulePathParts[idx])) {
                            break;
                        }
                    }
                    // if the context exactly matches the rule's path, we use an empty path for that rule.
                    // but, some rule types must have a non-empty path.
                    // if our context would give us an empty path for one of those rule types,
                    // use the context that comes before it, if available.
                    if ((rule instanceof exportable_1.ExportableCardRule ||
                        rule instanceof exportable_1.ExportableFlagRule ||
                        rule instanceof exportable_1.ExportableCombinedCardFlagRule ||
                        rule instanceof exportable_1.ExportableBindingRule ||
                        rule instanceof exportable_1.ExportableAssignmentRule ||
                        rule instanceof exportable_1.ExportableContainsRule ||
                        rule instanceof exportable_1.ExportableOnlyRule) &&
                        contextIndex > -1 &&
                        rule.path === pathContext[contextIndex]) {
                        contextIndex -= 1;
                    }
                    if (contextIndex > -1) {
                        // if our contextIndex ended up at least 0, we found a context to use!
                        rule.indent = contextIndex + 1;
                        // splice off from pathContext everything we're not using from pathContext
                        pathContext.splice(contextIndex + 1);
                        // rebuild the rule's path based on the context we're using now
                        // keep parts of the existing rule path starting at the index = number of parts from the path context being used
                        const newPath = rulePathParts
                            .splice(pathContext[pathContext.length - 1].split('.').length)
                            .join('.');
                        // if the rule has any path left after that, push its full path onto the pathContext list
                        if (newPath.length) {
                            // change soft-index marker because a matching path should use [=]
                            pathContext.push(rule.path.replace(/\[\+\]/g, '[=]'));
                        }
                        // assign the new path to the rule
                        rule.path = newPath;
                    }
                    else {
                        // we didn't find a context to use. so, the indent will be 0.
                        rule.indent = 0;
                        // get rid of all existing contexts, and push this rule's path (if it exists) on to pathContext
                        pathContext.splice(0);
                        // change soft-index marker because a matching path should use [=]
                        if (rule.path.length > 0) {
                            pathContext.push(rule.path.replace(/\[\+\]/g, '[=]'));
                        }
                    }
                });
            }
        });
    },
    isEnabled(options) {
        return options.indent === true;
    }
};
//# sourceMappingURL=SimplifyRulePathContextsOptimizer.js.map