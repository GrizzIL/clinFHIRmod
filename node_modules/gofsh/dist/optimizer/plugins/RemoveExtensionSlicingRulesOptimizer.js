"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const exportable_1 = require("../../exportable");
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const { FshCode } = fsh_sushi_1.fshtypes;
exports.default = {
    name: 'remove_extension_slicing_rules',
    description: 'Remove standard extension slicing rules that SUSHI automatically applies to extension paths',
    optimize(pkg) {
        [...pkg.profiles, ...pkg.extensions].forEach(sd => {
            const rulesToMaybeRemove = [];
            sd.rules.forEach((rule, i, allRules) => {
                if (rule instanceof exportable_1.ExportableCaretValueRule && /(modifierE|e)xtension$/.test(rule.path)) {
                    // * path ^slicing.discriminator[0].type = #value
                    const DEFAULT_SLICING_DISCRIMINATOR_TYPE = new exportable_1.ExportableCaretValueRule(rule.path);
                    DEFAULT_SLICING_DISCRIMINATOR_TYPE.caretPath = 'slicing.discriminator[0].type';
                    DEFAULT_SLICING_DISCRIMINATOR_TYPE.value = new FshCode('value');
                    // * path ^slicing.discriminator[0].value = "url"
                    const DEFAULT_SLICING_DISCRIMINATOR_PATH = new exportable_1.ExportableCaretValueRule(rule.path);
                    DEFAULT_SLICING_DISCRIMINATOR_PATH.caretPath = 'slicing.discriminator[0].path';
                    DEFAULT_SLICING_DISCRIMINATOR_PATH.value = 'url';
                    // * path ^slicing.ordered = false
                    const DEFAULT_SLICING_ORDERED = new exportable_1.ExportableCaretValueRule(rule.path);
                    DEFAULT_SLICING_ORDERED.caretPath = 'slicing.ordered';
                    DEFAULT_SLICING_ORDERED.value = false;
                    // * path ^slicing.rules = #open
                    const DEFAULT_SLICING_RULES = new exportable_1.ExportableCaretValueRule(rule.path);
                    DEFAULT_SLICING_RULES.caretPath = 'slicing.rules';
                    DEFAULT_SLICING_RULES.value = new FshCode('open');
                    const hasContainsRule = allRules.some(otherRule => otherRule instanceof exportable_1.ExportableContainsRule && otherRule.path === rule.path);
                    const hasOneSlicingDiscriminatorRule = !allRules.some(otherRule => otherRule.path === rule.path &&
                        otherRule instanceof exportable_1.ExportableCaretValueRule &&
                        otherRule.caretPath !== 'slicing.discriminator[0].type' &&
                        otherRule.caretPath !== 'slicing.discriminator[0].path' &&
                        otherRule.caretPath.startsWith('slicing.discriminator['));
                    if (
                    // One of the four default rules
                    (lodash_1.isEqual(rule, DEFAULT_SLICING_DISCRIMINATOR_TYPE) ||
                        lodash_1.isEqual(rule, DEFAULT_SLICING_DISCRIMINATOR_PATH) ||
                        lodash_1.isEqual(rule, DEFAULT_SLICING_ORDERED) ||
                        lodash_1.isEqual(rule, DEFAULT_SLICING_RULES)) &&
                        // Some contains rule at the same path
                        hasContainsRule &&
                        // No other slicing.discriminator rules at the same path
                        hasOneSlicingDiscriminatorRule) {
                        rulesToMaybeRemove.push(i);
                    }
                }
            });
            // If four rules to maybe remove have the same path, then that's a full set of defaults, and they are removed
            const rulesToRemove = lodash_1.flatten(lodash_1.values(lodash_1.groupBy(rulesToMaybeRemove, i => sd.rules[i].path)).filter(ruleGroup => ruleGroup.length === 4));
            lodash_1.pullAt(sd.rules, rulesToRemove);
        });
    }
};
//# sourceMappingURL=RemoveExtensionSlicingRulesOptimizer.js.map