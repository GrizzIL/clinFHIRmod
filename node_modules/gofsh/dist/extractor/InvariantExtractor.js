"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvariantExtractor = void 0;
const fsh_sushi_1 = require("fsh-sushi");
const lodash_1 = require("lodash");
const ExportableInvariant_1 = require("../exportable/ExportableInvariant");
class InvariantExtractor {
    static process(input, structDef, existingInvariants) {
        var _a;
        const invariants = [];
        if (((_a = input.constraint) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            input.constraint.forEach((constraint, i) => {
                const constraintPaths = [];
                // required: key, human, severity
                const invariant = new ExportableInvariant_1.ExportableInvariant(constraint.key);
                invariant.description = constraint.human;
                invariant.severity = new fsh_sushi_1.fshtypes.FshCode(constraint.severity);
                constraintPaths.push(`constraint[${i}].key`, `constraint[${i}].human`, `constraint[${i}].severity`);
                // optional: expression, xpath
                if (constraint.expression) {
                    invariant.expression = constraint.expression;
                    constraintPaths.push(`constraint[${i}].expression`);
                }
                if (constraint.xpath) {
                    invariant.xpath = constraint.xpath;
                    constraintPaths.push(`constraint[${i}].xpath`);
                }
                // SUSHI autopopulates source to the current SD URL, so as long as it matches, mark that path as processed
                if (constraint.source == null || constraint.source === structDef.url) {
                    constraintPaths.push(`constraint[${i}].source`);
                }
                // if an invariant with this key already exists, don't make a new invariant with the same key.
                // if the new invariant would be an exact match of the existing invariant, mark the paths as
                // processed so an ObeysRule is created and no CaretValueRules are created.
                // if the new invariant has a key match but isn't an exact match, it will be created using CaretValueRules.
                const matchingKeyInvariant = [...existingInvariants, ...invariants].find(inv => inv.name === constraint.key);
                if (matchingKeyInvariant) {
                    if (lodash_1.isEqual(matchingKeyInvariant, invariant)) {
                        input.processedPaths.push(...constraintPaths);
                    }
                }
                else {
                    input.processedPaths.push(...constraintPaths);
                    invariants.push(invariant);
                }
            });
        }
        return invariants;
    }
}
exports.InvariantExtractor = InvariantExtractor;
//# sourceMappingURL=InvariantExtractor.js.map