"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CaretValueRuleExtractor = void 0;
const fsh_sushi_1 = require("fsh-sushi");
const lodash_1 = require("lodash");
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
class CaretValueRuleExtractor {
    static process(input, structDef, fisher) {
        // Convert to json to remove extra private properties on fhirtypes.ElementDefinition
        const path = utils_1.getPath(input);
        const inputJSON = input.toJSON();
        input.processedPaths.push('id', 'path');
        const caretValueRules = [];
        const flatElementArray = lodash_1.toPairs(utils_1.getPathValuePairs(inputJSON));
        const remainingFlatElementArray = flatElementArray.filter(([key]) => !input.processedPaths.includes(key));
        remainingFlatElementArray.forEach(([key], i) => {
            var _a, _b, _c, _d, _e, _f;
            const caretValueRule = new exportable_1.ExportableCaretValueRule(path);
            caretValueRule.caretPath = key;
            caretValueRule.value = utils_1.getFSHValue(i, remainingFlatElementArray, 'ElementDefinition', fisher);
            // If the value is empty, we can't use it. Log an error and give up on trying to use this key.
            if (utils_1.isFSHValueEmpty(caretValueRule.value)) {
                utils_1.logger.error(`Value in StructureDefinition ${structDef.name} for element ${path}.${key} is empty. No caret value rule will be created.`);
                return;
            }
            // Fix constraint[n] indices if applicable. This is necessary because GoFSH will use constraint indices relative
            // to the constraint array in the differential, which may be a *subset* of the constraint array in the snapshot.
            // SUSHI, however, processes indices relative to the constraint array in the snapshot, so we need to adjust for
            // what SUSHI expects. If we can't adjust (due to missing snapshot), log a warning and comment the FSH.
            const constraintMatch = key.match(/constraint\[(\d+)]/);
            if (constraintMatch) {
                let newIndex;
                if (((_b = (_a = structDef === null || structDef === void 0 ? void 0 : structDef.snapshot) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                    const diffConstraint = inputJSON.constraint[parseInt(constraintMatch[1])];
                    const snapElement = findMatchingSnapshot(inputJSON.id, structDef);
                    newIndex = (_c = snapElement === null || snapElement === void 0 ? void 0 : snapElement.constraint) === null || _c === void 0 ? void 0 : _c.findIndex(c => c.key === diffConstraint.key);
                }
                if (newIndex != null) {
                    caretValueRule.caretPath = key.replace(constraintMatch[0], `constraint[${newIndex}]`);
                }
                else {
                    caretValueRule.fshComment =
                        `WARNING: The constraint index in the following rule (e.g., ${constraintMatch[0]}) may be incorrect.\n` +
                            "Please compare with the constraint array in the original definition's snapshot and adjust as necessary.";
                    utils_1.logger.warn(`Could not calculate correct constraint index relative to the snapshot for the following path in ${structDef.name}: ` +
                        `${path} ^${key}. To resolve this issue, run GoFSH on definitions that include valid snapshots; otherwise check and fix ` +
                        'constraint indices in the generated FSH files as necessary.');
                }
            }
            // Fix mapping[n] indices for all the same reasons and with all the same behaviors as for constraint above.
            // Unfortunately, it's just different enough that extracting a common function would only add complexity.
            const mappingMatch = key.match(/mapping\[(\d+)]/);
            if (mappingMatch) {
                let newIndex;
                if (((_e = (_d = structDef === null || structDef === void 0 ? void 0 : structDef.snapshot) === null || _d === void 0 ? void 0 : _d.element) === null || _e === void 0 ? void 0 : _e.length) > 0) {
                    const diffMapping = inputJSON.mapping[parseInt(mappingMatch[1])];
                    const snapElement = findMatchingSnapshot(inputJSON.id, structDef);
                    // Unlike constraint, which has guaranteed unique keys, we need to compare mapping as a whole to find a match
                    newIndex = (_f = snapElement === null || snapElement === void 0 ? void 0 : snapElement.mapping) === null || _f === void 0 ? void 0 : _f.findIndex(m => lodash_1.isEqual(m, diffMapping));
                }
                if (newIndex != null) {
                    caretValueRule.caretPath = key.replace(mappingMatch[0], `mapping[${newIndex}]`);
                }
                else {
                    caretValueRule.fshComment =
                        `WARNING: The mapping index in the following rule (e.g., ${mappingMatch[0]}) may be incorrect.\n` +
                            "Please compare with the mapping array in the original definition's snapshot and adjust as necessary.";
                    utils_1.logger.warn(`Could not calculate correct mapping index relative to the snapshot for the following path in ${structDef.name}: ` +
                        `${path} ^${key}. To resolve this issue, run GoFSH on definitions that include valid snapshots; otherwise check and fix ` +
                        'mapping indices in the generated FSH files as necessary.');
                }
            }
            caretValueRules.push(caretValueRule);
        });
        return caretValueRules;
    }
    static processStructureDefinition(input, fisher, config) {
        var _a;
        // Clone the input so we can modify it for simpler comparison
        const sd = lodash_1.cloneDeep(input);
        // Clone the parent so we can modify it for simpler comparison
        let parent = lodash_1.cloneDeep(fisher.fishForFHIR(input.baseDefinition, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Type, fsh_sushi_1.utils.Type.Profile, fsh_sushi_1.utils.Type.Extension, fsh_sushi_1.utils.Type.Logical));
        if (parent == null) {
            // We can't reliably export caret rules when we can't find the parent, but keep going
            // because we should still export the properties that SUSHI clears from the parent anyway
            // (properties that should always be exported).
            utils_1.logger.warn(`Cannot reliably export top-level caret rules for ${sd.name} because GoFSH cannot find a ` +
                `definition for its parent: ${sd.baseDefinition}. If its parent is from another IG, ` +
                'run GoFSH again declaring that IG as a dependency.');
            parent = lodash_1.cloneDeep(sd);
        }
        // Remove properties that are covered by other extractors or keywords
        RESOURCE_IGNORED_PROPERTIES['StructureDefinition'].forEach(prop => {
            delete sd[prop];
            delete parent[prop];
        });
        // If text exists and is generated, ignore it
        if (((_a = sd.text) === null || _a === void 0 ? void 0 : _a.status) === 'generated') {
            delete sd.text;
            delete parent.text;
        }
        // Remove properties from the parent that SUSHI clears before creating a profile. This
        // ensures that caret value rules will be exported even if the value is the same as the
        // parent (since SUSHI does not inherit these specific properties from the parent).
        // TODO: SUSHI should export the list of cleared properties or export a function that
        // clears them.
        SD_CLEARED_PROPERTIES.forEach(prop => delete parent[prop]);
        // Massage data to support arrays as best as possible. Unfortunately, FSH does not provide
        // full support for array manipulation. You cannot clear arrays, delete elements, replace
        // arrays, or append elements (unless you know the length). This makes things tricky for
        // GoFSH. For now we do the best we can, which is:
        // 1. If SD array and parent array are equal, do nothing (rely on inheritance)
        // 2. If SD array is subset of parent array, do nothing (FSH can't delete elements)
        // 3. If SD array is same length as parent array, but some elements differ, or if SD array
        //    is larger than the parent array:
        //    a. if extension or modifier extension, output caret rules for the whole array, because
        //       SUSHI modifies those arrays itself before applying rules, so the indices might be off
        //    b. otherwise output caret rules only for changed/added elements
        // To accomplish this, it's easier to manipulate the sd and parent JSON before flattening.
        // NOTE: This is only concerned w/ arrays at the top-level.
        Object.keys(sd).forEach(key => {
            if (Array.isArray(sd[key]) && sd[key].length) {
                let hasNewItems;
                if (Array.isArray(parent[key])) {
                    const newItems = lodash_1.differenceWith(sd[key], parent[key], lodash_1.isEqual);
                    hasNewItems = newItems.length > 0;
                }
                else {
                    hasNewItems = true;
                }
                if (hasNewItems && (key === 'extension' || key === 'modifierExtension')) {
                    // delete the items from the parent array, forcing the whole sd array to be exported
                    delete parent[key];
                }
                else if (!hasNewItems) {
                    // delete it from the SD so we won't create a caret rule for it even if it is a subset
                    delete sd[key];
                }
            }
        });
        const caretValueRules = [];
        const flatSD = utils_1.getPathValuePairs(sd);
        const flatArray = lodash_1.toPairs(flatSD);
        const flatParent = utils_1.getPathValuePairs(parent);
        flatArray.forEach(([key], i) => {
            if (flatParent[key] == null ||
                !lodash_1.isEqual(flatSD[key], flatParent[key]) ||
                // SUSHI always sets status to active, so if it isn't active, we need a caret rule
                (key === 'status' && flatSD[key] !== 'active')) {
                if (key === 'url' && this.isStandardURL('StructureDefinition', config, input)) {
                    return;
                }
                const caretValueRule = new exportable_1.ExportableCaretValueRule('');
                caretValueRule.caretPath = key;
                caretValueRule.value = utils_1.getFSHValue(i, flatArray, 'StructureDefinition', fisher);
                if (utils_1.isFSHValueEmpty(caretValueRule.value)) {
                    utils_1.logger.error(`Value in StructureDefinition ${input.name} for element ${key} is empty. No caret value rule will be created.`);
                }
                else {
                    caretValueRules.push(caretValueRule);
                }
            }
        });
        return caretValueRules;
    }
    static processResource(input, fisher, resourceType, config) {
        const caretValueRules = [];
        const flatArray = lodash_1.toPairs(utils_1.getPathValuePairs(input)).filter(([key]) => !RESOURCE_IGNORED_PROPERTIES[resourceType].some(property => key === property || new RegExp(`${property}(\\[\\d+\\])?\\.`).test(key)));
        flatArray.forEach(([key], i) => {
            var _a;
            if (key === 'url' && this.isStandardURL(resourceType, config, input)) {
                return;
            }
            const caretValueRule = new exportable_1.ExportableCaretValueRule('');
            caretValueRule.caretPath = key;
            caretValueRule.value = utils_1.getFSHValue(i, flatArray, resourceType, fisher);
            if (utils_1.isFSHValueEmpty(caretValueRule.value)) {
                utils_1.logger.error(`Value in ${resourceType} ${(_a = input.name) !== null && _a !== void 0 ? _a : input.id} for element ${key} is empty. No caret value rule will be created.`);
            }
            else {
                caretValueRules.push(caretValueRule);
            }
        });
        return caretValueRules;
    }
    static processConcept(input, conceptHierarchy, codeSystemName, fisher) {
        const caretValueRules = [];
        const flatArray = lodash_1.toPairs(utils_1.getPathValuePairs(input)).filter(([key]) => !CONCEPT_IGNORED_PROPERTIES.some(property => key === property || new RegExp(`${property}(\\[\\d+\\])?\\.`).test(key)));
        flatArray.forEach(([key], i) => {
            const caretValueRule = new exportable_1.ExportableCaretValueRule('');
            caretValueRule.caretPath = key;
            caretValueRule.value = utils_1.getFSHValue(i, flatArray, 'Concept', fisher);
            caretValueRule.isCodeCaretRule = true;
            caretValueRule.pathArray = conceptHierarchy;
            if (utils_1.isFSHValueEmpty(caretValueRule.value)) {
                utils_1.logger.error(`Value in CodeSytem ${codeSystemName} at concept ${conceptHierarchy.join('.')} for element ${caretValueRule.caretPath} is empty. No caret value rule will be created.`);
            }
            else {
                caretValueRules.push(caretValueRule);
            }
        });
        return caretValueRules;
    }
    static isStandardURL(resourceType, config, input) {
        return input.url == `${config.canonical}/${resourceType}/${input.id}`;
    }
}
exports.CaretValueRuleExtractor = CaretValueRuleExtractor;
function findMatchingSnapshot(differentialId, structDef) {
    var _a;
    return (_a = structDef.snapshot) === null || _a === void 0 ? void 0 : _a.element.find(el => {
        var _a, _b;
        if (el.id === differentialId) {
            return true;
        }
        else if (((_a = el.id) === null || _a === void 0 ? void 0 : _a.indexOf('[x]:')) > 0) {
            // We may not have matched due to the alternate syntax for choices.  E.g., if the differential id is
            // Observation.valueQuantity but the snapshot id is Observation.value[x]:valueQuantity. Get the corresponding
            // alternate syntax for the id and test against that. See: https://blog.fire.ly/2019/09/13/type-slicing-in-fhir-r4/
            const elIdAltSyntax = (_b = el.id) === null || _b === void 0 ? void 0 : _b.split('.').map(p => {
                const i = p.indexOf('[x]:');
                return i > -1 ? p.slice(i + 4) : p;
            }).join('.');
            return elIdAltSyntax === differentialId;
        }
        return false;
    });
}
const CONCEPT_IGNORED_PROPERTIES = ['code', 'display', 'definition', 'concept'];
const RESOURCE_IGNORED_PROPERTIES = {
    ValueSet: [
        'resourceType',
        'id',
        'name',
        'title',
        'description',
        'compose.include',
        'compose.exclude'
    ],
    CodeSystem: ['resourceType', 'id', 'name', 'title', 'description', 'concept'],
    StructureDefinition: [
        'resourceType',
        'id',
        'name',
        'title',
        'description',
        'fhirVersion',
        'mapping',
        'baseDefinition',
        'derivation',
        'snapshot',
        'differential'
    ]
};
// The properties that SUSHI clears before creating a profile
const SD_CLEARED_PROPERTIES = [
    'meta',
    'implicitRules',
    'language',
    'text',
    'contained',
    'identifier',
    'experimental',
    'date',
    'publisher',
    'contact',
    'useContext',
    'jurisdiction',
    'purpose',
    'copyright',
    'keyword'
];
//# sourceMappingURL=CaretValueRuleExtractor.js.map