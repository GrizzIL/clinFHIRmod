"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddElementRuleExtractor = void 0;
const lodash_1 = require("lodash");
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
const _1 = require(".");
const OnlyRuleExtractor_1 = require("./OnlyRuleExtractor");
class AddElementRuleExtractor {
    static process(input) {
        var _a;
        const addElementRule = new exportable_1.ExportableAddElementRule(utils_1.getPath(input));
        // we always have cardinality
        // don't use CardRuleExtractor here, since that has extra logic
        // that we don't want to use.
        addElementRule.min = input.min;
        addElementRule.max = input.max;
        input.processedPaths.push('min', 'max');
        // get types using OnlyRuleExtractor
        addElementRule.types = (_a = OnlyRuleExtractor_1.OnlyRuleExtractor.process(input)) === null || _a === void 0 ? void 0 : _a.types;
        // if types were missing, default to BackboneElement
        if (lodash_1.isEmpty(addElementRule.types)) {
            addElementRule.types = [{ type: 'BackboneElement' }];
            utils_1.logger.warn(`No types found for element ${input.id}. Defaulting to BackboneElement.`);
        }
        // we might have flags, so use FlagRuleExtractor
        const flagRule = _1.FlagRuleExtractor.process(input);
        if (flagRule) {
            Object.assign(addElementRule, flagRule);
        }
        // we might have short and definition
        if (input.short) {
            addElementRule.short = input.short;
            input.processedPaths.push('short');
        }
        if (input.definition) {
            addElementRule.definition = input.definition;
            input.processedPaths.push('definition');
        }
        return addElementRule;
    }
}
exports.AddElementRuleExtractor = AddElementRuleExtractor;
//# sourceMappingURL=AddElementRuleExtractor.js.map