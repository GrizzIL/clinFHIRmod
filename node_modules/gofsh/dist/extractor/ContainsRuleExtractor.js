"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainsRuleExtractor = void 0;
const exportable_1 = require("../exportable");
const utils_1 = require("../utils");
const CardRuleExtractor_1 = require("./CardRuleExtractor");
const FlagRuleExtractor_1 = require("./FlagRuleExtractor");
const utils_2 = require("../utils");
class ContainsRuleExtractor {
    static process(input, structDef, fisher) {
        var _a, _b, _c;
        // The path for the rule should not include the slice for the contained element,
        // but should include previous slices.
        const elementPath = utils_1.getPath(input);
        const sliceNameFromId = (_a = input.id.match(/[:/]([^:/]+)$/)) === null || _a === void 0 ? void 0 : _a[1];
        if (sliceNameFromId !== input.sliceName) {
            utils_2.logger.error(`Element sliceName "${input.sliceName}" is not correctly used to populate id "${input.id}" according to ` +
                'the algorithm specified here: https://www.hl7.org/fhir/elementdefinition.html#id. ' +
                'The value implied by the id will be used.');
        }
        const rulePath = elementPath.replace(RegExp(`\\[${sliceNameFromId}\\]$`), '');
        const containsRule = new exportable_1.ExportableContainsRule(rulePath);
        containsRule.items.push({
            name: sliceNameFromId
        });
        // CardRule is required, so try our best to get correct cardinality information
        // 1. Check the element differential
        // 2. Check the element snapshot
        // 3. Use defaults: min = 0, max = sliced element's max
        // Once both min and max are defined, the CardRule is ready to use.
        let cardRule = CardRuleExtractor_1.CardRuleExtractor.process(input, structDef, fisher, false);
        // if no information was available, the extractor will return null. but we need a rule!
        if (cardRule == null) {
            cardRule = new exportable_1.ExportableCardRule(elementPath);
        }
        // fill in missing information from snapshot
        if (cardRule.min == null || cardRule.max == null) {
            const snapshotElement = (_b = structDef.snapshot) === null || _b === void 0 ? void 0 : _b.element.find(el => el.id === input.id);
            if (cardRule.min == null && (snapshotElement === null || snapshotElement === void 0 ? void 0 : snapshotElement.min) != null) {
                cardRule.min = snapshotElement.min;
            }
            if (cardRule.max == null && (snapshotElement === null || snapshotElement === void 0 ? void 0 : snapshotElement.max) != null) {
                cardRule.max = snapshotElement.max;
            }
        }
        // fill in missing information using defaults
        if (cardRule.min == null) {
            cardRule.min = 0;
        }
        if (cardRule.max == null) {
            const slicedElementId = input.id.slice(0, input.id.lastIndexOf(':'));
            const card = utils_1.getCardinality(slicedElementId, structDef, fisher);
            if (card) {
                cardRule.max = (_c = card === null || card === void 0 ? void 0 : card.max) !== null && _c !== void 0 ? _c : '*';
            }
            else {
                // we couldn't find the cardinality of the sliced element, which means this slice is probably not valid
                return null;
            }
        }
        containsRule.cardRules.push(cardRule);
        // FlagRule is optional
        const flagRule = FlagRuleExtractor_1.FlagRuleExtractor.process(input);
        if (flagRule) {
            containsRule.flagRules.push(flagRule);
        }
        input.processedPaths.push('sliceName');
        return containsRule;
    }
}
exports.ContainsRuleExtractor = ContainsRuleExtractor;
//# sourceMappingURL=ContainsRuleExtractor.js.map