"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappingExtractor = void 0;
const fsh_sushi_1 = require("fsh-sushi");
const lodash_1 = require("lodash");
const exportable_1 = require("../exportable");
const processor_1 = require("../processor");
const utils_1 = require("../utils");
class MappingExtractor {
    static process(input, elements, fisher) {
        var _a, _b, _c;
        const mappings = this.extractMappings(input, elements);
        // Filter out mappings on the parent - only include mappings new to the profile
        // or mappings on the base definition with additional mapping rules
        // TODO: Look for parents from the local package being processed. This requires a MasterFisher.
        const parent = fisher.fishForFHIR(input.baseDefinition, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Type, fsh_sushi_1.utils.Type.Profile, fsh_sushi_1.utils.Type.Extension, fsh_sushi_1.utils.Type.Logical);
        // If there is no parent found, all the mappings should be exported.
        if (parent == null || !processor_1.StructureDefinitionProcessor.isProcessableStructureDefinition(parent)) {
            return mappings;
        }
        const parentSDElements = (_c = (_b = (_a = parent.snapshot) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.map(rawElement => {
            return processor_1.ProcessableElementDefinition.fromJSON(rawElement, false);
        })) !== null && _c !== void 0 ? _c : [];
        const parentMappings = this.extractMappings(parent, parentSDElements, true);
        // Only return mappings that are new to the profile or inherited mappings with new MappingRules
        const newMappings = [];
        mappings.forEach(mapping => {
            const parentMapping = parentMappings.find(pm => pm.id === mapping.id);
            // filter rules to include only those not in a parent
            mapping.rules = mapping.rules.filter(rule => !(parentMapping === null || parentMapping === void 0 ? void 0 : parentMapping.rules.find(r => lodash_1.isEqual(r, rule))));
            // if there wasn't a parent at all or if there are new rules not in the parent, it's new
            if (parentMapping == null || mapping.rules.length > 0) {
                newMappings.push(mapping);
            }
        });
        return newMappings;
    }
    static extractMappings(sd, elements, processingParent = false) {
        const mappings = (sd.mapping || []).map(m => {
            const mapping = new exportable_1.ExportableMapping(`${m.identity}-for-${sd.name}`);
            mapping.id = m.identity;
            mapping.source = sd.name;
            if (m.name)
                mapping.title = m.name;
            if (m.uri)
                mapping.target = m.uri;
            if (m.comment)
                mapping.description = m.comment;
            return mapping;
        });
        elements.forEach(element => {
            this.extractRules(element, sd, mappings, processingParent);
        });
        return mappings;
    }
    static extractRules(element, sd, mappings, processingParent = false) {
        var _a;
        (_a = element.mapping) === null || _a === void 0 ? void 0 : _a.forEach((mapping, i) => {
            let matchingMapping = mappings.find(m => m.id === mapping.identity);
            if (matchingMapping == null) {
                // There should always be a matching mapping, but some IGs seem to be missing some top-level mappings
                // (I'm looking at you US Core 3.1.1).  When a mapping is missing, create one on the fly, but log
                // a warning and write a comment.
                matchingMapping = new exportable_1.ExportableMapping(`${mapping.identity}-for-${sd.name}`);
                matchingMapping.id = mapping.identity;
                matchingMapping.source = sd.name;
                if (!processingParent) {
                    matchingMapping.fshComment =
                        `WARNING: The following Mapping may be incomplete since the original ${sd.name}\n` +
                            `StructureDefinition was missing the mapping entry for ${matchingMapping.id}.\n` +
                            'Please review this and add the following properties as necessary: Target, Title, Description';
                    utils_1.logger.warn(`Element in ${sd.name} references undefined SD-level mapping: ${matchingMapping.id}. GoFSH has created a new Mapping named ` +
                        `${matchingMapping.name}. Please review and edit the Mapping in your FSH files to provide additional information.`);
                }
                mappings.push(matchingMapping);
            }
            matchingMapping.rules.push(this.processMappingRule(element, mapping, i));
        });
    }
    static processMappingRule(element, mapping, i) {
        let path = utils_1.getPath(element);
        if (path === '.')
            path = ''; // Root path in mappings is an empty string
        const mappingRule = new exportable_1.ExportableMappingRule(path);
        mappingRule.map = mapping.map;
        element.processedPaths.push(`mapping[${i}].identity`);
        element.processedPaths.push(`mapping[${i}].map`);
        if (mapping.comment) {
            mappingRule.comment = mapping.comment;
            element.processedPaths.push(`mapping[${i}].comment`);
        }
        if (mapping.language) {
            mappingRule.language = new fsh_sushi_1.fshtypes.FshCode(mapping.language);
            element.processedPaths.push(`mapping[${i}].language`);
        }
        return mappingRule;
    }
}
exports.MappingExtractor = MappingExtractor;
//# sourceMappingURL=MappingExtractor.js.map