"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LakeOfFHIR = void 0;
const fsh_sushi_1 = require("fsh-sushi");
const lodash_1 = require("lodash");
const CodeSystemProcessor_1 = require("./CodeSystemProcessor");
const InstanceProcessor_1 = require("./InstanceProcessor");
const StructureDefinitionProcessor_1 = require("./StructureDefinitionProcessor");
const ValueSetProcessor_1 = require("./ValueSetProcessor");
const utils_1 = require("../utils");
// Like FSHTank in SUSHI, but it doesn't contain FSH, it contains FHIR.  And who ever heard of a tank of FHIR?  But a lake of FHIR...
class LakeOfFHIR {
    constructor(docs) {
        this.docs = docs;
    }
    /**
     * Gets all non-instance structure definitions (profiles, extensions, logicals, and resources) in the lake
     * @returns {WildFHIR[]}
     */
    getAllStructureDefinitions() {
        return this.docs
            .filter(d => d.content.resourceType === 'StructureDefinition')
            .filter(d => !this.isSDForInstance(d));
    }
    /**
     * Gets all value sets in the lake, optionally excluding value sets that can't be processed using FSH ValueSet syntax
     * @param includeUnsupported - indicates if value sets that can't be processed using FSH ValueSet syntax should be returned
     * @returns {WildFHIR[]}
     */
    getAllValueSets(includeUnsupported = true) {
        return this.docs.filter(d => d.content.resourceType === 'ValueSet' &&
            (includeUnsupported || ValueSetProcessor_1.ValueSetProcessor.isProcessableValueSet(d.content)));
    }
    /**
     * Gets all code systems in the lake, optionally excluding code systems that can't be processed using FSH CodeSystem syntax
     * @param includeUnsupported - indicates if code systems that can't be processed using FSH CodeSystem syntax should be returned
     * @returns {WildFHIR[]}
     */
    getAllCodeSystems(includeUnsupported = true) {
        return this.docs.filter(d => d.content.resourceType === 'CodeSystem' &&
            (includeUnsupported || CodeSystemProcessor_1.CodeSystemProcessor.isProcessableCodeSystem(d.content)));
    }
    /**
     * Gets all implementation guides in the lake
     * @returns {WildFHIR[]}
     */
    getAllImplementationGuides() {
        return this.docs.filter(d => d.content.resourceType === 'ImplementationGuide');
    }
    /**
     * Gets all instances in the lake, optionally including value sets / code systems that can't be processed using FSH VS/CS syntax
     * @param includeUnsupported - indicates if terminology resources that can't be processed using FSH VS/CS syntax should be returned
     * @returns {WildFHIR[]}
     */
    getAllInstances(includeUnsupportedTerminologyResources = false) {
        return this.docs.filter(d => {
            switch (d.content.resourceType) {
                case 'ImplementationGuide':
                    return false;
                case 'StructureDefinition':
                    return this.isSDForInstance(d);
                case 'CodeSystem':
                    return (includeUnsupportedTerminologyResources &&
                        !CodeSystemProcessor_1.CodeSystemProcessor.isProcessableCodeSystem(d.content));
                case 'ValueSet':
                    return (includeUnsupportedTerminologyResources &&
                        !ValueSetProcessor_1.ValueSetProcessor.isProcessableValueSet(d.content));
                default:
                    return true;
            }
        });
    }
    isSpecialization(d) {
        return (d.content.resourceType === 'StructureDefinition' && d.content.derivation === 'specialization');
    }
    // A StructureDefinition can represent many different FSH types:
    // Profile, Extension, Logical, Resource, Instance
    // The first four are handled by the StructureDefinitionProcessor, but Instances are handled by InstanceProcessor.
    // Thus, splitting the categories based on that is useful.
    // The important fields here are kind and derivation.
    // A Profile has kind "resource", "complex-type", "logical", or "primitive-type" and derivation "constraint".
    // An Extension has kind "complex-type", derivation "constraint", and type "Extension". It's a special case of Profile.
    // A Logical has kind "logical" and derivation "specialization".
    // A Resource has kind "resource" and derivation "specialization".
    // Any other combination of values for kind and derivation represents an Instance.
    isSDForInstance(d) {
        if (d.content.resourceType === 'StructureDefinition') {
            if (d.content.derivation === 'specialization') {
                return ['primitive-type', 'complex-type'].includes(d.content.kind);
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    fishForFHIR(item, ...types) {
        // The simplest approach is just to re-use the FHIRDefinitions fisher.  But since this.docs can be modified by anyone at any time
        // the only safe way to do this is by rebuilding a FHIRDefinitions object each time we need it.  If this becomes a performance
        // concern, we can optimize it later -- but performance isn't a huge concern in GoFSH. Note also that this approach may need to be
        // updated if we ever need to support fishing for Instances.
        const defs = new fsh_sushi_1.fhirdefs.FHIRDefinitions();
        this.docs.forEach(d => defs.add(d.content));
        return defs.fishForFHIR(item, ...types);
    }
    fishForMetadata(item, ...types) {
        // The simplest approach is just to re-use the FHIRDefinitions fisher.  But since this.docs can be modified by anyone at any time
        // the only safe way to do this is by rebuilding a FHIRDefinitions object each time we need it.  If this becomes a performance
        // concern, we can optimize it later -- but performance isn't a huge concern in GoFSH. Note also that this approach may need to be
        // updated if we ever need to support fishing for Instances.
        const defs = new fsh_sushi_1.fhirdefs.FHIRDefinitions();
        this.docs.forEach(d => defs.add(d.content));
        return defs.fishForMetadata(item, ...types);
    }
    /**
     * Removes any definitions from this.docs that have the same resourceType and id as
     * a previous definition, as long as there is a defined id.
     * Logs an error when it finds a duplicate
     */
    removeDuplicateDefinitions() {
        const dupPaths = [];
        this.docs = lodash_1.uniqWith(this.docs, (a, b) => {
            const isDuplicate = a.content.id != null &&
                a.content.id === b.content.id &&
                a.content.resourceType === b.content.resourceType;
            if (isDuplicate) {
                dupPaths.push(`${a.path} (${a.content.resourceType}/${a.content.id}) matches ${b.path}`);
            }
            return isDuplicate;
        });
        if (dupPaths.length > 0) {
            utils_1.logger.error(`Encountered ${dupPaths.length} definition(s) with the same resourceType and id as a previous definition. ` +
                'FHIR definitions should have unique resourceType and id. The following duplicate definitions will not be processed by GoFSH:' +
                `\n  - ${dupPaths.join('\n  - ')}`);
        }
    }
    /**
     * All definitions that will be Instances should have a resourceType and id.
     * If any Instance is missing an id, we add one.
     * If the instance is a conformance or terminology resource, we try to base the id off the name if it is available.
     * If there is no name or if it is any other type of resource, we add a clearly generated id with a counter.
     * Log a warning if it finds any definitions without an id
     */
    assignMissingIds() {
        const createdIdPaths = [];
        let generatedId = 0;
        this.docs.forEach((d, index) => {
            var _a;
            const isSpecialFSHType = StructureDefinitionProcessor_1.StructureDefinitionProcessor.isProcessableStructureDefinition(d.content) ||
                CodeSystemProcessor_1.CodeSystemProcessor.isProcessableCodeSystem(d.content) ||
                ValueSetProcessor_1.ValueSetProcessor.isProcessableValueSet(d.content);
            if (d.content.id == null && !isSpecialFSHType) {
                if (InstanceProcessor_1.CONFORMANCE_AND_TERMINOLOGY_RESOURCES.has(d.content.resourceType)) {
                    // Try to be smart and set the id to the existing name
                    d.content.id = (_a = d.content.name) === null || _a === void 0 ? void 0 : _a.replace(/_/g, '-').slice(0, 64); // Turn a valid name into a valid id
                }
                if (d.content.id == null) {
                    // If a Conformance/Terminology instance didn't have a name or if this any other resourceType, generate an id with a counter
                    d.content.id = `GOFSH-GENERATED-ID-${generatedId++}`;
                    // If another definition happen to have the same id as the one we just generated with a counter, increase the counter
                    while (this.docs.some((a, i) => a.content.id === d.content.id && index !== i)) {
                        d.content.id = `GOFSH-GENERATED-ID-${generatedId++}`;
                    }
                }
                createdIdPaths.push(`${d.path} (${d.content.resourceType}/${d.content.id})`);
            }
        });
        if (createdIdPaths.length > 0) {
            utils_1.logger.warn(`Encountered ${createdIdPaths.length} definition(s) that were missing an id. GoFSH created ids for the following:` +
                `\n  - ${createdIdPaths.join('\n  - ')}`);
        }
    }
}
exports.LakeOfFHIR = LakeOfFHIR;
//# sourceMappingURL=LakeOfFHIR.js.map