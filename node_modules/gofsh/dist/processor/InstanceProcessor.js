"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CONFORMANCE_AND_TERMINOLOGY_RESOURCES = exports.InstanceProcessor = void 0;
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const exportable_1 = require("../exportable");
const common_1 = require("../exportable/common");
const utils_1 = require("../utils");
const _1 = require(".");
class InstanceProcessor {
    static extractKeywords(input, target, implementationGuide, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        if (options.metaProfile === 'first') {
            target.instanceOf =
                ((_b = (_a = input.meta) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.length) > 0 ? input.meta.profile[0] : input.resourceType;
        }
        else if (options.metaProfile === 'none') {
            target.instanceOf = input.resourceType;
        }
        else {
            target.instanceOf =
                ((_d = (_c = input.meta) === null || _c === void 0 ? void 0 : _c.profile) === null || _d === void 0 ? void 0 : _d.length) === 1 ? input.meta.profile[0] : input.resourceType;
        }
        const resource = (_f = (_e = implementationGuide === null || implementationGuide === void 0 ? void 0 : implementationGuide.definition) === null || _e === void 0 ? void 0 : _e.resource) === null || _f === void 0 ? void 0 : _f.find((resource) => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === `${input.resourceType}/${input.id}`; });
        target.name = `${target.name}-of-${target.instanceOf}`;
        if (resource) {
            if (resource.name) {
                target.title = resource.name;
            }
            if (resource.description) {
                target.description = resource.description;
            }
            target.usage =
                resource.exampleBoolean || resource.exampleCanonical ? 'Example' : 'Definition';
        }
        else {
            target.usage = exports.CONFORMANCE_AND_TERMINOLOGY_RESOURCES.has(input.resourceType)
                ? 'Definition'
                : 'Example';
        }
    }
    static extractRules(input, target, fisher, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        const newRules = [];
        // Clone input so it can be modified
        const inputJSON = lodash_1.cloneDeep(input);
        let instanceOfJSON = fisher.fishForFHIR(target.instanceOf, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Profile, fsh_sushi_1.utils.Type.Extension, fsh_sushi_1.utils.Type.Type);
        if (instanceOfJSON == null) {
            if (((_b = (_a = input.meta) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                utils_1.logger.warn(`InstanceOf definition not found for ${input.id}. The ResourceType of the instance will be used as a base.`);
                target.instanceOf = input.resourceType;
            }
            instanceOfJSON = fisher.fishForFHIR(input.resourceType, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Profile, fsh_sushi_1.utils.Type.Extension, fsh_sushi_1.utils.Type.Type);
            if (instanceOfJSON == null) {
                utils_1.logger.error(`Definition of ResourceType not found for ${input.id}. Cannot export any Assignment Rules`);
                return;
            }
        }
        else if ((((_d = (_c = inputJSON.meta) === null || _c === void 0 ? void 0 : _c.profile) === null || _d === void 0 ? void 0 : _d.length) === 1 && options.metaProfile !== 'none') ||
            (((_f = (_e = inputJSON.meta) === null || _e === void 0 ? void 0 : _e.profile) === null || _f === void 0 ? void 0 : _f.length) > 0 && options.metaProfile === 'first')) {
            // If we found JSON for the profile, delete it from meta.profile.
            inputJSON.meta.profile.splice(0, 1);
            if (lodash_1.isEmpty(inputJSON.meta.profile)) {
                delete inputJSON.meta.profile;
            }
            if (lodash_1.isEmpty(inputJSON.meta)) {
                delete inputJSON.meta;
            }
        }
        IGNORED_PROPERTIES.forEach(prop => {
            delete inputJSON[prop];
        });
        if (((_g = inputJSON.text) === null || _g === void 0 ? void 0 : _g.status) === 'generated') {
            delete inputJSON.text;
        }
        const flatInstanceArray = lodash_1.toPairs(utils_1.getPathValuePairs(inputJSON));
        flatInstanceArray.forEach(([key], i) => {
            // Remove any _ at the start of any path part
            const path = common_1.removeUnderscoreForPrimitiveChildPath(key);
            const assignmentRule = new exportable_1.ExportableAssignmentRule(path);
            assignmentRule.value = utils_1.getFSHValue(i, flatInstanceArray, instanceOfJSON.type, fisher);
            // if the value is empty, we can't use that
            if (utils_1.isFSHValueEmpty(assignmentRule.value)) {
                utils_1.logger.error(`Value in Instance ${target.name} at path ${key} is empty. No assignment rule will be created.`);
            }
            else {
                newRules.push(assignmentRule);
            }
        });
        target.rules = lodash_1.compact(newRules);
        _1.switchQuantityRules(target.rules);
    }
    static process(input, implementationGuide, fisher, options = {}) {
        const instance = new exportable_1.ExportableInstance(input.id);
        InstanceProcessor.extractKeywords(input, instance, implementationGuide, options);
        InstanceProcessor.extractRules(input, instance, fisher, options);
        return instance;
    }
}
exports.InstanceProcessor = InstanceProcessor;
// List of Conformance and Terminology resources from http://hl7.org/fhir/R4/resourcelist.html
exports.CONFORMANCE_AND_TERMINOLOGY_RESOURCES = new Set([
    'CapabilityStatement',
    'StructureDefinition',
    'ImplementationGuide',
    'SearchParameter',
    'MessageDefinition',
    'OperationDefinition',
    'CompartmentDefinition',
    'StructureMap',
    'GraphDefinition',
    'ExampleScenario',
    'CodeSystem',
    'ValueSet',
    'ConceptMap',
    'NamingSystem',
    'TerminologyCapabilities'
]);
// The properties that are handled via keywords
const IGNORED_PROPERTIES = ['resourceType', 'id'];
//# sourceMappingURL=InstanceProcessor.js.map