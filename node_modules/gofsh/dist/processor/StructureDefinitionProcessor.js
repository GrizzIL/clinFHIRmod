"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructureDefinitionProcessor = void 0;
const lodash_1 = require("lodash");
const exportable_1 = require("../exportable");
const extractor_1 = require("../extractor");
const _1 = require(".");
const utils_1 = require("../utils");
class StructureDefinitionProcessor {
    static process(input, fisher, config, existingInvariants = []) {
        var _a, _b, _c, _d;
        if (StructureDefinitionProcessor.isProcessableStructureDefinition(input)) {
            let sd;
            // Prefer name (which is required). If we happen to get invalid FHIR, create a reasonable name from the id with only allowable characters
            const name = (_a = input.name) !== null && _a !== void 0 ? _a : input.id.split(/[-.]+/).map(lodash_1.capitalize).join('');
            if (input.kind === 'logical' && input.derivation === 'specialization') {
                sd = new exportable_1.ExportableLogical(name);
            }
            else if (input.kind === 'resource' && input.derivation === 'specialization') {
                sd = new exportable_1.ExportableResource(name);
            }
            else if (input.kind === 'complex-type' &&
                input.derivation === 'constraint' &&
                input.type === 'Extension') {
                sd = new exportable_1.ExportableExtension(name);
            }
            else if (input.derivation === 'constraint') {
                sd = new exportable_1.ExportableProfile(name);
            }
            else {
                // this should never be encountered when running normally, hopefully,
                // since the LakeOfFHIR should only be providing us with non-Instance StructureDefinitions
                throw new Error('This StructureDefinition does not represent a FSH Profile, Extension, Logical, or Resource.');
            }
            const elements = (_d = (_c = (_b = input.differential) === null || _b === void 0 ? void 0 : _b.element) === null || _c === void 0 ? void 0 : _c.map(rawElement => {
                return _1.ProcessableElementDefinition.fromJSON(rawElement, false);
            })) !== null && _d !== void 0 ? _d : [];
            StructureDefinitionProcessor.extractKeywords(input, sd);
            const invariants = StructureDefinitionProcessor.extractInvariants(input, elements, existingInvariants);
            const mappings = StructureDefinitionProcessor.extractMappings(elements, input, fisher);
            StructureDefinitionProcessor.extractRules(input, elements, sd, fisher, config);
            _1.makeNameSushiSafe(sd);
            // TODO: Destructuring an array with invariants and mappings is required for TypeScript 3.0
            // With TypeScript 4.0, we should update to return the following line, which is more clear:
            // return [sd, ...invariants, ...mappings];
            return [sd, ...[...invariants, ...mappings]];
        }
        return [];
    }
    static extractKeywords(input, target) {
        // Name is already set (by constructor) based on input.name or input.id
        if (input.id) {
            target.id = input.id;
        }
        if (input.title) {
            target.title = input.title;
        }
        if (input.description) {
            target.description = input.description;
        }
        if (input.baseDefinition) {
            target.parent = input.baseDefinition;
        }
    }
    static extractRules(input, elements, target, fisher, config) {
        const newRules = [];
        let parentDefinition;
        if (input.baseDefinition) {
            parentDefinition = fisher.fishForFHIR(input.baseDefinition);
        }
        else if (target instanceof exportable_1.ExportableResource) {
            parentDefinition = fisher.fishForFHIR('http://hl7.org/fhir/StructureDefinition/DomainResource');
        }
        else if (target instanceof exportable_1.ExportableLogical) {
            parentDefinition = fisher.fishForFHIR('http://hl7.org/fhir/StructureDefinition/Base');
        }
        // First extract the top-level caret rules from the StructureDefinition
        newRules.push(...extractor_1.CaretValueRuleExtractor.processStructureDefinition(input, fisher, config));
        // Then extract rules based on the differential elements
        elements.forEach(element => {
            var _a, _b;
            const ancestorSliceDefinition = utils_1.getAncestorSliceDefinition(element, input, fisher);
            // if there is a slice, which is not a choice slice, but no ancestor definition, it will need a contains rule
            const isNewSlice = element.sliceName &&
                !/\[x]:[a-z][a-z0-9]*[A-Z][A-Za-z0-9]*$/.test(element.id) &&
                ancestorSliceDefinition == null;
            if ((target instanceof exportable_1.ExportableResource || target instanceof exportable_1.ExportableLogical) &&
                !((_b = (_a = parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.snapshot) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.some(parentEl => parentEl.id === element.id))) {
                // a newly defined element on a Resource or Logical needs an AddElementRule
                // AddElementRule contains cardinality, flag, and type information, so those extractors don't need to be called here
                // the root element doesn't need to be added, but all other elements do.
                // but, we still want to mark paths as processed so that caret value rules are not made.
                if (isNewSlice) {
                    utils_1.logger.warn(`${target.constructorName} ${target.name} contains a slice definition for ${element.sliceName} on ${element.path}. This is not supported by FHIR.`);
                    newRules.push(extractor_1.ContainsRuleExtractor.process(element, input, fisher));
                }
                else {
                    if (element.path.indexOf('.') === -1) {
                        // For the root element, mark the cardinality paths as processed
                        // so that they don't get CaretValueRules created.
                        element.processedPaths.push('min', 'max');
                    }
                    else {
                        // For all other elements, make a rule to add them.
                        const addElementRule = extractor_1.AddElementRuleExtractor.process(element);
                        newRules.push(addElementRule);
                    }
                }
                newRules.push(extractor_1.BindingRuleExtractor.process(element), extractor_1.ObeysRuleExtractor.process(element));
                const assignmentRules = extractor_1.AssignmentRuleExtractor.process(element);
                if (assignmentRules.length > 0) {
                    utils_1.logger.warn(`${target.constructorName} ${target.name} contains value assignment for ${element.id}. This is not supported by FHIR.`);
                    newRules.push(...assignmentRules);
                }
            }
            else if (isNewSlice) {
                newRules.push(extractor_1.ContainsRuleExtractor.process(element, input, fisher), extractor_1.OnlyRuleExtractor.process(element), ...extractor_1.AssignmentRuleExtractor.process(element), extractor_1.BindingRuleExtractor.process(element), extractor_1.ObeysRuleExtractor.process(element));
            }
            else {
                newRules.push(extractor_1.CardRuleExtractor.process(element, input, fisher), extractor_1.OnlyRuleExtractor.process(element), ...extractor_1.AssignmentRuleExtractor.process(element), extractor_1.FlagRuleExtractor.process(element), extractor_1.BindingRuleExtractor.process(element), extractor_1.ObeysRuleExtractor.process(element));
            }
            // if there is a slice, and there is an ancestor definition, don't process the sliceName again
            if (element.sliceName && ancestorSliceDefinition) {
                element.processedPaths.push('sliceName');
            }
            // NOTE: CaretValueExtractor for elements can only run once other Extractors have finished,
            // since it will convert any remaining fields to CaretValueRules
            newRules.push(...extractor_1.CaretValueRuleExtractor.process(element, input, fisher));
        });
        target.rules = lodash_1.compact(newRules);
        _1.switchQuantityRules(target.rules);
    }
    static extractInvariants(input, elements, existingInvariants) {
        const invariants = [];
        elements.forEach(element => {
            invariants.push(...extractor_1.InvariantExtractor.process(element, input, [...existingInvariants, ...invariants]));
        });
        return invariants;
    }
    static extractMappings(elements, input, fisher) {
        return extractor_1.MappingExtractor.process(input, elements, fisher);
    }
    static isProcessableStructureDefinition(input) {
        return input.resourceType === 'StructureDefinition' && (input.name != null || input.id != null);
    }
}
exports.StructureDefinitionProcessor = StructureDefinitionProcessor;
//# sourceMappingURL=StructureDefinitionProcessor.js.map