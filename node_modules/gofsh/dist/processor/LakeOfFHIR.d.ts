import { utils } from 'fsh-sushi';
import { WildFHIR } from './WildFHIR';
export declare class LakeOfFHIR implements utils.Fishable {
    docs: WildFHIR[];
    constructor(docs: WildFHIR[]);
    /**
     * Gets all non-instance structure definitions (profiles, extensions, logicals, and resources) in the lake
     * @returns {WildFHIR[]}
     */
    getAllStructureDefinitions(): WildFHIR[];
    /**
     * Gets all value sets in the lake, optionally excluding value sets that can't be processed using FSH ValueSet syntax
     * @param includeUnsupported - indicates if value sets that can't be processed using FSH ValueSet syntax should be returned
     * @returns {WildFHIR[]}
     */
    getAllValueSets(includeUnsupported?: boolean): WildFHIR[];
    /**
     * Gets all code systems in the lake, optionally excluding code systems that can't be processed using FSH CodeSystem syntax
     * @param includeUnsupported - indicates if code systems that can't be processed using FSH CodeSystem syntax should be returned
     * @returns {WildFHIR[]}
     */
    getAllCodeSystems(includeUnsupported?: boolean): WildFHIR[];
    /**
     * Gets all implementation guides in the lake
     * @returns {WildFHIR[]}
     */
    getAllImplementationGuides(): WildFHIR[];
    /**
     * Gets all instances in the lake, optionally including value sets / code systems that can't be processed using FSH VS/CS syntax
     * @param includeUnsupported - indicates if terminology resources that can't be processed using FSH VS/CS syntax should be returned
     * @returns {WildFHIR[]}
     */
    getAllInstances(includeUnsupportedTerminologyResources?: boolean): WildFHIR[];
    isSpecialization(d: WildFHIR): boolean;
    isSDForInstance(d: WildFHIR): boolean;
    fishForFHIR(item: string, ...types: utils.Type[]): any;
    fishForMetadata(item: string, ...types: utils.Type[]): utils.Metadata;
    /**
     * Removes any definitions from this.docs that have the same resourceType and id as
     * a previous definition, as long as there is a defined id.
     * Logs an error when it finds a duplicate
     */
    removeDuplicateDefinitions(): void;
    /**
     * All definitions that will be Instances should have a resourceType and id.
     * If any Instance is missing an id, we add one.
     * If the instance is a conformance or terminology resource, we try to base the id off the name if it is available.
     * If there is no name or if it is any other type of resource, we add a clearly generated id with a counter.
     * Log a warning if it finds any definitions without an id
     */
    assignMissingIds(): void;
}
