"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeSystemProcessor = void 0;
const lodash_1 = require("lodash");
const exportable_1 = require("../exportable");
const extractor_1 = require("../extractor");
const common_1 = require("./common");
class CodeSystemProcessor {
    static extractKeywords(input, target) {
        if (input.id) {
            target.id = input.id;
        }
        if (input.title) {
            target.title = input.title;
        }
        if (input.description) {
            target.description = input.description;
        }
    }
    static extractRules(input, target, fisher, config) {
        var _a;
        const newRules = [];
        newRules.push(...extractor_1.CaretValueRuleExtractor.processResource(input, fisher, input.resourceType, config));
        (_a = input.concept) === null || _a === void 0 ? void 0 : _a.forEach((concept) => {
            newRules.push(...this.extractConceptRules(concept, input.name || input.id, fisher));
        });
        target.rules = lodash_1.compact(newRules);
    }
    static extractConceptRules(concept, codeSystemName, fisher, hierarchy) {
        const conceptRules = [];
        const newConceptRule = new exportable_1.ExportableConceptRule(concept.code, concept.display, concept.definition);
        newConceptRule.hierarchy = hierarchy !== null && hierarchy !== void 0 ? hierarchy : [];
        conceptRules.push(newConceptRule, ...extractor_1.CaretValueRuleExtractor.processConcept(concept, [...newConceptRule.hierarchy, concept.code], codeSystemName, fisher));
        if (concept.concept) {
            const hierarchyArr = lodash_1.clone(newConceptRule.hierarchy);
            hierarchyArr.push(concept.code);
            concept.concept.forEach((child) => {
                conceptRules.push(...this.extractConceptRules(child, codeSystemName, fisher, hierarchyArr));
            });
        }
        return conceptRules;
    }
    static process(input, fisher, config) {
        var _a;
        // It must be representable using the FSH CodeSystem syntax
        if (this.isProcessableCodeSystem(input)) {
            // Prefer name (which is optional), otherwise create a reasonable name from the id with only allowable characters
            const name = (_a = input.name) !== null && _a !== void 0 ? _a : input.id.split(/[-.]+/).map(lodash_1.capitalize).join('');
            const codeSystem = new exportable_1.ExportableCodeSystem(name);
            CodeSystemProcessor.extractKeywords(input, codeSystem);
            CodeSystemProcessor.extractRules(input, codeSystem, fisher, config);
            common_1.makeNameSushiSafe(codeSystem);
            return codeSystem;
        }
    }
    // Ensures that a CodeSystem instance is fully representable using the CodeSystem syntax in FSH.
    // If there is no name or id we cannot process it.
    static isProcessableCodeSystem(input) {
        return input.resourceType === 'CodeSystem' && (input.name || input.id);
    }
}
exports.CodeSystemProcessor = CodeSystemProcessor;
//# sourceMappingURL=CodeSystemProcessor.js.map