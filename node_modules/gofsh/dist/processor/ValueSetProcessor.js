"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetProcessor = void 0;
const lodash_1 = require("lodash");
const flat_1 = require("flat");
const exportable_1 = require("../exportable");
const extractor_1 = require("../extractor");
const common_1 = require("./common");
const SUPPORTED_COMPONENT_PATHS = [
    'system',
    'version',
    'concept',
    'concept.code',
    'concept.display',
    'filter',
    'filter.property',
    'filter.op',
    'filter.value',
    'valueSet'
];
class ValueSetProcessor {
    static extractKeywords(input, target) {
        if (input.id) {
            target.id = input.id;
        }
        if (input.title) {
            target.title = input.title;
        }
        if (input.description) {
            target.description = input.description;
        }
    }
    static extractRules(input, target, fisher, config) {
        var _a, _b;
        const newRules = [];
        newRules.push(...extractor_1.CaretValueRuleExtractor.processResource(input, fisher, input.resourceType, config));
        if (input.compose) {
            (_a = input.compose.include) === null || _a === void 0 ? void 0 : _a.forEach((vsComponent) => {
                newRules.push(extractor_1.ValueSetFilterComponentRuleExtractor.process(vsComponent, input, true));
                newRules.push(extractor_1.ValueSetConceptComponentRuleExtractor.process(vsComponent, true));
            });
            (_b = input.compose.exclude) === null || _b === void 0 ? void 0 : _b.forEach((vsComponent) => {
                newRules.push(extractor_1.ValueSetFilterComponentRuleExtractor.process(vsComponent, input, false));
                newRules.push(extractor_1.ValueSetConceptComponentRuleExtractor.process(vsComponent, false));
            });
        }
        target.rules = lodash_1.compact(newRules);
    }
    static process(input, fisher, config) {
        var _a;
        // It must be representable using the FSH ValueSet syntax
        if (ValueSetProcessor.isProcessableValueSet(input)) {
            // Prefer name (which is optional), otherwise create a reasonable name from the id with only allowable characters
            const name = (_a = input.name) !== null && _a !== void 0 ? _a : input.id.split(/[-.]+/).map(lodash_1.capitalize).join('');
            const valueSet = new exportable_1.ExportableValueSet(name);
            ValueSetProcessor.extractKeywords(input, valueSet);
            ValueSetProcessor.extractRules(input, valueSet, fisher, config);
            common_1.makeNameSushiSafe(valueSet);
            return valueSet;
        }
    }
    // Ensures that a ValueSet instance is fully representable using the ValueSet syntax in FSH.
    // For example, if there is no name or id we cannot process it.  In addition, if compose.include
    // or compose.exclude have extensions, or concepts have designations, etc., then we can't
    // represent it in FSH ValueSet syntax.  It must be represented using Instance instead.
    // NOTE: by FHIR spec, if the include list exists, it must contain at least one element
    // but we can still do some processing without that as long as other criteria holds.
    // See http://hl7.org/fhir/r4/valueset-definitions.html#ValueSet.compose.include
    static isProcessableValueSet(input) {
        var _a, _b, _c, _d;
        if (input.resourceType !== 'ValueSet' || (input.name == null && input.id == null)) {
            return false;
        }
        // We support all higher-level paths via caret rules.  We only need to worry about the
        // input.compose.include and input.compose.exclude components because there is no easy way
        // to associate caret rules with them when the special FSH include/exclude syntax is used.
        // First get the flat paths of input.compose.include and input.compose.exclude
        let flatPaths = Object.keys(flat_1.flatten([...((_b = (_a = input.compose) === null || _a === void 0 ? void 0 : _a.include) !== null && _b !== void 0 ? _b : []), ...((_d = (_c = input.compose) === null || _c === void 0 ? void 0 : _c.exclude) !== null && _d !== void 0 ? _d : [])]));
        // Remove the array indices from the paths (we don't care about them)
        flatPaths = flatPaths.map(p => {
            return p
                .split('.')
                .filter(k => isNaN(parseInt(k)))
                .join('.');
        });
        // Check if there are any paths that are not a supported path
        return lodash_1.difference(flatPaths, SUPPORTED_COMPONENT_PATHS).length === 0;
    }
}
exports.ValueSetProcessor = ValueSetProcessor;
//# sourceMappingURL=ValueSetProcessor.js.map