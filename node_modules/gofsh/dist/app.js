#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = __importDefault(require("commander"));
const chalk_1 = __importDefault(require("chalk"));
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const utils_1 = require("./utils");
const FSH_VERSION = '1.2.0';
app().catch(e => {
    utils_1.logger.error(`Unexpected error: ${e.message}`);
    process.exit(1);
});
function app() {
    var _a, _b, _c, _d, _e, _f, _g;
    return __awaiter(this, void 0, void 0, function* () {
        let inDir;
        commander_1.default
            .name('goFSH')
            .usage('[path-to-fhir-resources] [options]')
            .option('-o, --out <out>', 'the path to the output folder')
            .option('-l, --log-level <level>', 'specify the level of log messages: error, warn, info (default), debug')
            .option('-d, --dependency <dependency...>', 'specify dependencies to be loaded using format dependencyId@version (FHIR R4 included by default)')
            .option('-s, --style <style>', 'specify how the output is organized into files: file-per-definition (default), group-by-fsh-type, group-by-profile, single-file')
            .option('-f, --fshing-trip', 'run SUSHI on the output of GoFSH and generate a comparison of the round trip results')
            .option('-i, --installed-sushi', 'use the locally installed version of SUSHI when generating comparisons with the "-f" option')
            .option('-t, --file-type <type>', 'specify which file types GoFSH should accept as input: json-only (default), xml-only, json-and-xml')
            .option('--indent', 'output FSH with indented rules using context paths')
            .option('--meta-profile <mode>', 'specify how meta.profile on Instances should be applied to the InstanceOf keyword: only-one (default), first, none')
            .version(getVersion(), '-v, --version', 'print goFSH version')
            .on('--help', () => {
            console.log('');
            console.log('goFSH is used to convert JSON FHIR resources');
            console.log('to FSH. This makes it easier to start');
            console.log('using FSH to author FHIR resources.');
        })
            .arguments('[path-to-fsh-defs]')
            .action(function (pathToFhirResources) {
            inDir = pathToFhirResources;
        })
            .parse(process.argv);
        // Set the log level. If no level specified, loggers default to info
        const { logLevel } = commander_1.default;
        if (logLevel === 'debug' || logLevel === 'warn' || logLevel === 'error') {
            utils_1.logger.level = logLevel; // GoFSH logger
            fsh_sushi_1.utils.logger.level = logLevel; // SUSHI logger
        }
        utils_1.logger.info(`Starting ${getVersion()}`);
        inDir = utils_1.getInputDir(inDir);
        let outDir;
        try {
            outDir = utils_1.ensureOutputDir(commander_1.default.out);
        }
        catch (err) {
            utils_1.logger.error(`Could not use output directory: ${err.message}`);
            process.exit(1);
        }
        if (!outDir) {
            utils_1.logger.info('Exiting.');
            process.exit(1);
        }
        // Load dependencies
        const defs = new fsh_sushi_1.fhirdefs.FHIRDefinitions();
        // Trim empty spaces from command line dependencies
        const dependencies = (_a = commander_1.default.dependency) === null || _a === void 0 ? void 0 : _a.map((dep) => dep.trim());
        // Load FhirProcessor and config object
        const fileType = (_c = (_b = commander_1.default.fileType) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== null && _c !== void 0 ? _c : 'json-only';
        if (!['json-only', 'xml-only', 'json-and-xml'].includes(fileType)) {
            utils_1.logger.error(`Unsupported "file-type" option: ${fileType}. Valid options are "json-only", "xml-only", and "json-and-xml".`);
            process.exit(1);
        }
        const metaProfileBehavior = (_e = (_d = commander_1.default.metaProfile) === null || _d === void 0 ? void 0 : _d.toLowerCase()) !== null && _e !== void 0 ? _e : 'only-one';
        if (!['only-one', 'first', 'none'].includes(metaProfileBehavior)) {
            utils_1.logger.error(`Unsupported "meta-profile" option: ${metaProfileBehavior}. Valid options are "only-one", "first", and "none".`);
            process.exit(1);
        }
        // Get options for processors and optimizers
        const processingOptions = {
            indent: commander_1.default.indent === true,
            metaProfile: metaProfileBehavior
        };
        const processor = utils_1.getFhirProcessor(inDir, defs, fileType);
        const config = processor.processConfig(dependencies);
        // Load dependencies from config for GoFSH processing
        const allDependencies = (_g = (_f = config.config.dependencies) === null || _f === void 0 ? void 0 : _f.map((dep) => `${dep.packageId}@${dep.version}`)) !== null && _g !== void 0 ? _g : [];
        const fhirPackageId = config.config.fhirVersion[0].startsWith('4.0')
            ? 'hl7.fhir.r4.core'
            : 'hl7.fhir.r5.core';
        allDependencies.push(`${fhirPackageId}@${config.config.fhirVersion[0]}`);
        const dependencyDefs = utils_1.loadExternalDependencies(defs, allDependencies);
        yield Promise.all(dependencyDefs);
        let pkg;
        try {
            pkg = yield utils_1.getResources(processor, config, processingOptions);
        }
        catch (err) {
            utils_1.logger.error(`Could not use input directory: ${err.message}`);
            process.exit(1);
        }
        utils_1.writeFSH(pkg, outDir, commander_1.default.style);
        const proNum = lodash_1.pad(pkg.profiles.length.toString(), 18);
        const extNum = lodash_1.pad(pkg.extensions.length.toString(), 17);
        const logNum = lodash_1.pad(pkg.logicals.length.toString(), 18);
        const resNum = lodash_1.pad(pkg.resources.length.toString(), 18);
        const vsNum = lodash_1.pad(pkg.valueSets.length.toString(), 17);
        const csNum = lodash_1.pad(pkg.codeSystems.length.toString(), 18);
        const instNum = lodash_1.pad(pkg.instances.length.toString(), 18);
        const invNum = lodash_1.pad(pkg.invariants.length.toString(), 17);
        const mapNum = lodash_1.pad(pkg.mappings.length.toString(), 18);
        const errNumMsg = lodash_1.pad(`${utils_1.stats.numError} Error${utils_1.stats.numError !== 1 ? 's' : ''}`, 12);
        const wrnNumMsg = lodash_1.padStart(`${utils_1.stats.numWarn} Warning${utils_1.stats.numWarn !== 1 ? 's' : ''}`, 12);
        const aWittyMessageInvolvingABadFishPun = lodash_1.padEnd(utils_1.getRandomPun(utils_1.stats.numError, utils_1.stats.numWarn), 37);
        const clr = utils_1.stats.numError > 0 ? chalk_1.default.red : utils_1.stats.numWarn > 0 ? chalk_1.default.rgb(179, 98, 0) : chalk_1.default.green;
        // prettier-ignore
        const results = [
            clr('╔' + '═════════════════════════ GoFSH RESULTS ═════════════════════════' + '╗'),
            clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
            clr('║') + ' │      Profiles      │    Extensions     │      Logicals      │ ' + clr('║'),
            clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
            clr('║') + ` │ ${proNum} │ ${extNum} │ ${logNum} │ ` + clr('║'),
            clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
            clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
            clr('║') + ' │     Resources      │     ValueSets     │     CodeSystems    │ ' + clr('║'),
            clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
            clr('║') + ` │ ${resNum} │ ${vsNum} │ ${csNum} │ ` + clr('║'),
            clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
            clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
            clr('║') + ' │     Instances      │    Invariants     │      Mappings      │ ' + clr('║'),
            clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
            clr('║') + ` │ ${instNum} │ ${invNum} │ ${mapNum} │ ` + clr('║'),
            clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
            clr('║') + '                                                                 ' + clr('║'),
            clr('╠' + '═════════════════════════════════════════════════════════════════' + '╣'),
            clr('║') + ` ${aWittyMessageInvolvingABadFishPun} ${errNumMsg} ${wrnNumMsg} ` + clr('║'),
            clr('╚' + '═════════════════════════════════════════════════════════════════' + '╝')
        ];
        console.log();
        results.forEach(r => console.log(r));
        if (commander_1.default.fshingTrip) {
            if (fileType === 'xml-only') {
                utils_1.logger.error('FSHing Trip is not supported for XML inputs.');
                process.exit(1);
            }
            else if (fileType === 'json-and-xml') {
                utils_1.logger.warn('FSHing Trip is not supported for XML inputs. Comparisons will only be generated for JSON input files.');
            }
            utils_1.fshingTrip(inDir, outDir, commander_1.default.installedSushi);
        }
        process.exit(0);
    });
}
function getVersion() {
    var _a;
    const packageJSONPath = path_1.default.join(__dirname, '..', 'package.json');
    if (fs_extra_1.default.existsSync(packageJSONPath)) {
        const goFshVersion = (_a = fs_extra_1.default.readJSONSync(packageJSONPath)) === null || _a === void 0 ? void 0 : _a.version;
        return `goFSH v${goFshVersion} (implements FHIR Shorthand specification v${FSH_VERSION})`;
    }
    return 'unknown';
}
//# sourceMappingURL=app.js.map