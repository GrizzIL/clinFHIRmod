"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MasterFisher = void 0;
const fsh_sushi_1 = require("fsh-sushi");
const processor_1 = require("../processor");
/**
 * The MasterFisher can fish from the LakeOfFHIR and external definitions. When the MasterFisher fishes,
 * it fishes in the LakeOfFHIR first and then the external definitions.  This essentially prefers local
 * definitions first (when there are naming clashes) - matching the SUSHI MasterFisher behavior.
 */
class MasterFisher {
    constructor(lakeOfFHIR = new processor_1.LakeOfFHIR([]), external = new fsh_sushi_1.fhirdefs.FHIRDefinitions()) {
        this.lakeOfFHIR = lakeOfFHIR;
        this.external = external;
    }
    fishForStructureDefinition(item) {
        const json = this.fishForFHIR(item, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Profile, fsh_sushi_1.utils.Type.Extension, fsh_sushi_1.utils.Type.Type);
        if (json) {
            // It is possible we can't parse the json, most likely if it doesn't have a snapshot
            // if that is the case we don't want actual errors, just return nothing
            try {
                return fsh_sushi_1.fhirtypes.StructureDefinition.fromJSON(json);
            }
            catch (_a) { }
        }
    }
    fishForFHIR(item, ...types) {
        var _a;
        return (_a = this.lakeOfFHIR.fishForFHIR(item, ...types)) !== null && _a !== void 0 ? _a : this.external.fishForFHIR(item, ...types);
    }
    fishForMetadata(item, ...types) {
        var _a;
        return ((_a = this.lakeOfFHIR.fishForMetadata(item, ...types)) !== null && _a !== void 0 ? _a : this.external.fishForMetadata(item, ...types));
    }
}
exports.MasterFisher = MasterFisher;
//# sourceMappingURL=MasterFisher.js.map