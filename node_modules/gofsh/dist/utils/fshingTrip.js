"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fshingTrip = void 0;
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const diff_1 = require("diff");
const Diff2html = __importStar(require("diff2html"));
const child_process_1 = require("child_process");
const temp_1 = __importDefault(require("temp"));
const lodash_1 = require("lodash");
const fs_extra_1 = __importDefault(require("fs-extra"));
const _1 = require(".");
function fshingTrip(inDir, outDir, useLocalSUSHI) {
    // Make a pretty box to let the user know we are going into SUSHI mode
    const clr = chalk_1.default.rgb(77, 166, 255);
    // prettier-ignore
    [
        clr('╔' + '═════════════════════════════════════════════════════════════════' + '╗'),
        clr('║') + '             Generating round trip results via SUSHI             ' + clr('║'),
        clr('╚' + '═════════════════════════════════════════════════════════════════' + '╝')
    ].forEach(line => console.log(line));
    // If we run with "npx", then the version GoFSH depends on will be used. Otherwise if the
    // user sets the "use-local-sushi" flag, use their globally installed SUSHI
    try {
        child_process_1.execSync(`${useLocalSUSHI ? '' : 'npx '}sushi ${outDir}`, { stdio: 'inherit' });
    }
    catch (_a) {
        _1.logger.warn('SUSHI finished with errors, this may affect the resulting comparison');
    }
    const inputFilesMap = getFilesMap(inDir);
    const outputFilesMap = getFilesMap(outDir);
    const files = lodash_1.union(Array.from(inputFilesMap.keys()), Array.from(outputFilesMap.keys())).filter(file => !['.index.json', 'ig-r4.json', 'package.json'].includes(file) &&
        !file.endsWith('openapi.json'));
    files.sort();
    temp_1.default.track();
    const diffFile = temp_1.default.openSync({ suffix: '.diff' });
    files.forEach(file => {
        var _a, _b, _c, _d, _e;
        const inputFilePath = (_a = inputFilesMap.get(file)) !== null && _a !== void 0 ? _a : path_1.default.join(inDir, file);
        const outputFilePath = (_b = outputFilesMap.get(file)) !== null && _b !== void 0 ? _b : path_1.default.join(outDir, file);
        let inputFileJSON = fs_extra_1.default.existsSync(inputFilePath) ? fs_extra_1.default.readJSONSync(inputFilePath) : '';
        const outputFileJSON = fs_extra_1.default.existsSync(outputFilePath) ? fs_extra_1.default.readJSONSync(outputFilePath) : '';
        // When comparing input to output, ignore snapshot, generated text, generated dates, and
        // root differential elements, since these will always differ from the output, and create
        // unnecessary diffs
        const originalInputJSON = lodash_1.cloneDeep(inputFileJSON);
        delete inputFileJSON.snapshot;
        const generatedText = ['generated', 'extensions'].includes((_c = inputFileJSON.text) === null || _c === void 0 ? void 0 : _c.status);
        if (generatedText) {
            delete inputFileJSON.text;
        }
        const generatedDate = inputFileJSON.date && !outputFileJSON.date;
        if (generatedDate) {
            delete inputFileJSON.date;
        }
        const emptyRootDifferential = ((_e = (_d = inputFileJSON.differential) === null || _d === void 0 ? void 0 : _d.element) === null || _e === void 0 ? void 0 : _e.length) &&
            lodash_1.isEqual(Object.keys(inputFileJSON.differential.element[0]), ['id', 'path']);
        if (emptyRootDifferential) {
            inputFileJSON.differential.element.splice(0, 1);
        }
        // If two files are deeply equal, show no diff
        if (lodash_1.isEqual(inputFileJSON, outputFileJSON)) {
            return;
        }
        // If there are non snapshot or generated text diffs, add notes indicating why snapshot and
        // generated text should be ignored
        inputFileJSON = originalInputJSON;
        if (inputFileJSON.snapshot) {
            inputFileJSON.snapshot =
                'NOTE: Snapshots are not generated by SUSHI, so this element is omitted for sake of comparison';
        }
        if (generatedText) {
            inputFileJSON.text =
                'NOTE: Generated text is ignored by GoFSH, so this element is omitted for sake of comparison';
        }
        if (generatedDate) {
            inputFileJSON.date =
                'NOTE: Generated date is ignored by GoFSH, so this element is omitted for sake of comparison';
        }
        if (emptyRootDifferential) {
            inputFileJSON.differential.element[0] =
                'NOTE: Root differential is ignored by GoFSH, so this element is omitted for sake of comparison';
        }
        const patch = diff_1.createTwoFilesPatch(path_1.default.relative(process.cwd(), inputFilePath), path_1.default.relative(process.cwd(), outputFilePath), JSON.stringify(inputFileJSON, null, 2).replace(/^""$/, ''), JSON.stringify(outputFileJSON, null, 2).replace(/^""$/, ''));
        if (!/@@/.test(patch)) {
            // No difference found
            return;
        }
        fs_extra_1.default.appendFileSync(diffFile.fd, patch, { encoding: 'utf8' });
    });
    try {
        const diffJson = Diff2html.parse(fs_extra_1.default.readFileSync(diffFile.path, 'utf-8'));
        const diffHtml = Diff2html.html(diffJson, { outputFormat: 'side-by-side', drawFileList: true });
        const template = fs_extra_1.default.readFileSync(path_1.default.join(__dirname, 'template.html'), 'utf-8');
        const resultFile = path_1.default.join(outDir, 'fshing-trip-comparison.html');
        fs_extra_1.default.writeFileSync(resultFile, template.replace('<!--diff2html-diff-->', diffHtml), 'utf-8');
        _1.logger.info(`Generated comparison file to ${resultFile}`);
    }
    catch (e) {
        _1.logger.error(`Comparison generation failed with error: ${e.message}`);
    }
}
exports.fshingTrip = fshingTrip;
function getFilesMap(dir) {
    const files = _1.getFilesRecursive(dir).filter(file => file.endsWith('.json'));
    const filesMap = new Map();
    files.forEach(file => filesMap.set(path_1.default.basename(file), file));
    return filesMap;
}
//# sourceMappingURL=fshingTrip.js.map