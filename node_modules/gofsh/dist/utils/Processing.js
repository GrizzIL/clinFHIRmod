"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilesRecursive = exports.getIgPathFromIgIni = exports.isProcessableContent = exports.readJSONorXML = exports.getLakeOfFHIR = exports.loadExternalDependencies = exports.writeFSH = exports.getResources = exports.getFhirProcessor = exports.ensureOutputDir = exports.getInputDir = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const ini_1 = __importDefault(require("ini"));
const readline_sync_1 = __importDefault(require("readline-sync"));
const fsh_sushi_1 = require("fsh-sushi");
const GoFSHLogger_1 = require("./GoFSHLogger");
const processor_1 = require("../processor");
const FSHExporter_1 = require("../export/FSHExporter");
const optimizer_1 = require("../optimizer");
const utils_1 = require("../utils");
const fhir_1 = require("fhir/fhir");
const FHIRConverter = new fhir_1.Fhir();
function getInputDir(input = '.') {
    // default to current directory
    GoFSHLogger_1.logger.info(`Using input directory: ${input}`);
    return input;
}
exports.getInputDir = getInputDir;
function ensureOutputDir(output = path_1.default.join('.', 'gofsh')) {
    GoFSHLogger_1.logger.info(`Using output directory: ${output}`);
    fs_extra_1.default.ensureDirSync(output);
    if (fs_extra_1.default.readdirSync(output).length > 0) {
        const continuationOption = readline_sync_1.default.keyIn([
            `Output directory ${output} contains files. How would you like to proceed?`,
            '- [D]elete',
            '- [C]ontinue',
            '- [Q]uit',
            'Choose one [D,C,Q]: '
        ].join('\n'), { limit: 'DCQ', cancel: false });
        if (/[Dd]/.test(continuationOption)) {
            fs_extra_1.default.emptyDirSync(output);
        }
        else if (/[Qq]/.test(continuationOption)) {
            return;
        }
    }
    return output;
}
exports.ensureOutputDir = ensureOutputDir;
function getFhirProcessor(inDir, defs, fileType) {
    const lake = getLakeOfFHIR(inDir, fileType);
    // Assign any missing ids where we can before filtering out duplicates so that all
    // the definitions with the same resourceType without an id don't get filtered out.
    lake.assignMissingIds();
    lake.removeDuplicateDefinitions();
    const igIniIgPath = getIgPathFromIgIni(inDir);
    const fisher = new utils_1.MasterFisher(lake, defs);
    return new processor_1.FHIRProcessor(lake, fisher, igIniIgPath);
}
exports.getFhirProcessor = getFhirProcessor;
function getResources(processor, config, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const fisher = processor.getFisher();
        const resources = processor.process(config, options);
        // Dynamically load and run the optimizers
        GoFSHLogger_1.logger.info('Optimizing FSH definitions to follow best practices...');
        const optimizers = yield optimizer_1.loadOptimizers();
        optimizers.forEach(opt => {
            if (typeof opt.isEnabled !== 'function' || opt.isEnabled(options)) {
                GoFSHLogger_1.logger.info(`Running optimizer ${opt.name}: ${opt.description}`);
                opt.optimize(resources, fisher, options);
            }
            else {
                GoFSHLogger_1.logger.debug(`Skipping optimizer ${opt.name}: ${opt.description}`);
            }
        });
        return resources;
    });
}
exports.getResources = getResources;
function writeFSH(resources, outDir, style) {
    const exporter = new FSHExporter_1.FSHExporter(resources);
    try {
        const resourceDir = path_1.default.join(outDir, 'input', 'fsh');
        exporter.export(style).forEach((content, name) => {
            fs_extra_1.default.ensureFileSync(path_1.default.join(resourceDir, name));
            fs_extra_1.default.writeFileSync(path_1.default.join(resourceDir, name), content);
        });
        GoFSHLogger_1.logger.info(`Wrote fsh to ${resourceDir}.`);
        if (resources.configuration) {
            const configPath = path_1.default.join(outDir, 'sushi-config.yaml');
            fs_extra_1.default.writeFileSync(configPath, resources.configuration.toFSH());
            GoFSHLogger_1.logger.info(`Wrote config to ${configPath}.`);
        }
    }
    catch (error) {
        GoFSHLogger_1.logger.error(`Could not write to output directory: ${error.message}`);
        process.exit(1);
    }
}
exports.writeFSH = writeFSH;
function loadExternalDependencies(defs, dependencies = []) {
    // Automatically include FHIR R4 if no other versions of FHIR are already included
    if (!dependencies.some(dep => /hl7\.fhir\.r[45]\.core/.test(dep))) {
        dependencies.push('hl7.fhir.r4.core@4.0.1');
    }
    // Load dependencies
    const dependencyDefs = [];
    for (const dep of dependencies) {
        const [packageId, version] = dep.split('@');
        if (version == null) {
            GoFSHLogger_1.logger.error(`Failed to load ${packageId}: No version specified. To specify the version use ` +
                `the format ${packageId}@current`);
            continue;
        }
        dependencyDefs.push(fsh_sushi_1.fhirdefs
            .loadDependency(packageId, version, defs)
            .then(def => {
            return def;
        })
            .catch(e => {
            GoFSHLogger_1.logger.error(`Failed to load ${dep}: ${e.message}`);
        }));
    }
    return dependencyDefs;
}
exports.loadExternalDependencies = loadExternalDependencies;
function getLakeOfFHIR(inDir, fileType) {
    const files = getFilesRecursive(inDir);
    const jsonFiles = files.filter(f => f.endsWith('.json'));
    const xmlFiles = files.filter(f => f.endsWith('.xml'));
    const docs = [];
    if (fileType === 'json-only') {
        GoFSHLogger_1.logger.info(`Found ${jsonFiles.length} JSON files.`);
        loadPrimaryFiles(jsonFiles, docs);
        const nonDuplicateXMLFiles = findNonDuplicateSecondaryFiles(xmlFiles, docs);
        if (nonDuplicateXMLFiles.length > 0) {
            // We only find the first non-duplicate file and warn on it, because warnings for every non-duplicate may be annoying
            GoFSHLogger_1.logger.warn(`${nonDuplicateXMLFiles.length} XML definition(s) found without corresponding JSON definitions (for example, ${nonDuplicateXMLFiles[0]}).` +
                ' These definitions will be ignored since GoFSH is running in "json-only" mode.' +
                ' To process XML definitions along with JSON, set the "-t" flag to "json-and-xml".' +
                ' To process only XML definitions, set the "-t" flag to "xml-only".');
        }
    }
    else if (fileType === 'xml-only') {
        GoFSHLogger_1.logger.info(`Found ${xmlFiles.length} XML files.`);
        loadPrimaryFiles(xmlFiles, docs);
        const nonDuplicateJSONFiles = findNonDuplicateSecondaryFiles(jsonFiles, docs);
        if (nonDuplicateJSONFiles.length > 0) {
            // We only find the first non-duplicate file and warn on it, because warnings for every non-duplicate may be annoying
            GoFSHLogger_1.logger.warn(`${nonDuplicateJSONFiles.length} JSON definition(s) found without corresponding XML definitions (for example, ${nonDuplicateJSONFiles[0]}).` +
                ' These definitions will be ignored since GoFSH is running in "xml-only" mode.' +
                ' To process JSON definitions along with XML, set the "-t" flag to "json-and-xml".' +
                ' To process only JSON definitions, set the "-t" flag to "json-only", or leave it unset.');
        }
    }
    else if (fileType === 'json-and-xml') {
        GoFSHLogger_1.logger.info(`Found ${jsonFiles.length} JSON files.`);
        loadPrimaryFiles(jsonFiles, docs);
        GoFSHLogger_1.logger.info(`Found ${xmlFiles.length} XML files.`);
        loadPrimaryFiles(xmlFiles, docs);
    }
    return new processor_1.LakeOfFHIR(docs);
}
exports.getLakeOfFHIR = getLakeOfFHIR;
function loadPrimaryFiles(files, docs) {
    files.forEach(file => {
        try {
            const loadedFile = readJSONorXML(file);
            if (isProcessableContent(loadedFile.content, file)) {
                docs.push(new processor_1.WildFHIR(loadedFile, file));
            }
        }
        catch (ex) {
            // If an "Unknown resource type" error is logged, we can be almost
            // certain that it is an xml file that should be ignored, so only log
            // a debug and not an error
            if (path_1.default.extname(file) === '.xml' && /Unknown resource type:/.test(ex.message)) {
                GoFSHLogger_1.logger.debug(`Skipping non-FHIR XML: ${file}`);
            }
            else {
                GoFSHLogger_1.logger.error(`Could not load ${file}: ${ex.message}`);
            }
        }
    });
}
function findNonDuplicateSecondaryFiles(files, docs) {
    return files.filter(file => {
        try {
            const content = readJSONorXML(file).content;
            return (isProcessableContent(content, file) &&
                content.id &&
                !docs.some(existingResource => existingResource.content.resourceType === content.resourceType &&
                    existingResource.content.id === content.id));
        }
        catch (_a) { } // We don't want to log any errors with the secondary files
    });
}
function readJSONorXML(file) {
    if (file.endsWith('.json')) {
        const buffer = fs_extra_1.default.readFileSync(file);
        const importedFile = {
            content: JSON.parse(buffer.toString().replace(/^\uFEFF/, ''))
        };
        if (buffer.length > LARGE_FILE_BUFFER_LENGTH) {
            importedFile.large = true;
        }
        return importedFile;
    }
    else if (file.endsWith('.xml')) {
        const buffer = fs_extra_1.default.readFileSync(file);
        const importedFile = { content: FHIRConverter.xmlToObj(buffer.toString()) };
        if (buffer.length > LARGE_FILE_BUFFER_LENGTH) {
            importedFile.large = true;
        }
        return importedFile;
    }
}
exports.readJSONorXML = readJSONorXML;
function isProcessableContent(content, source) {
    if (typeof content !== 'object' || content.resourceType == null) {
        GoFSHLogger_1.logger.debug(`Skipping non-FHIR input: ${source}`);
        return false;
    }
    else if (/^http:\/\/hl7.org\/fhir\/comparison\//.test(content.url)) {
        // The IG Publisher creates weird "Intersection" and "Union" SD files, so this check filters them out
        GoFSHLogger_1.logger.debug(`Skipping temporary "comparison" resource created by IG Publisher: ${source}`);
        return false;
    }
    else if (source === null || source === void 0 ? void 0 : source.endsWith(path_1.default.join('other', 'validation-oo.json'))) {
        // The IG Publisher creates a Bundle of OperationOutcome resources based on validation results, which we don't want
        GoFSHLogger_1.logger.debug(`Skipping validation outcome resource created by IG Publisher: ${source}`);
        return false;
    }
    else {
        return true;
    }
}
exports.isProcessableContent = isProcessableContent;
function getIgPathFromIgIni(inDir) {
    var _a;
    let igPath;
    const igIniPath = getFilesRecursive(inDir).find(file => path_1.default.parse(file).base === 'ig.ini');
    if (igIniPath) {
        try {
            const igIni = ini_1.default.parse(fs_extra_1.default.readFileSync(igIniPath, 'utf-8'));
            if ((_a = igIni.IG) === null || _a === void 0 ? void 0 : _a.ig) {
                igPath = path_1.default.join(path_1.default.dirname(igIniPath), igIni.IG.ig);
            }
        }
        catch (_b) { }
    }
    return igPath;
}
exports.getIgPathFromIgIni = getIgPathFromIgIni;
// thanks, peturv
function getFilesRecursive(dir) {
    if (fs_extra_1.default.statSync(dir).isDirectory()) {
        const ancestors = fs_extra_1.default.readdirSync(dir, 'utf8').map(f => {
            // Don't get any files in .git folder or in a child temp folder
            if (f === 'temp' || f === '.git') {
                GoFSHLogger_1.logger.debug(`Skipping ${f} folder: ${path_1.default.join(dir, f)}`);
                return [];
            }
            return getFilesRecursive(path_1.default.join(dir, f));
        });
        return [].concat(...ancestors);
    }
    else {
        // IG Publisher creates .escaped.json files that are not valid JSON
        if (dir.endsWith('.escaped.json') ||
            dir.endsWith('-spreadsheet.xml') ||
            IGNORED_RESOURCE_LIKE_FILES.some(path => dir.endsWith(path)) ||
            IGNORED_NON_RESOURCE_DIRECTORIES.some(path => dir.includes(path))) {
            GoFSHLogger_1.logger.debug(`Skipping ${dir} file`);
            return [];
        }
        return [dir];
    }
}
exports.getFilesRecursive = getFilesRecursive;
const IGNORED_RESOURCE_LIKE_FILES = [
    // If expansions.json is in an output directory, it was likely generated by the IG Publisher
    // Since it is a generated file and it can be large, we skip processing it
    `output${path_1.default.sep}expansions.json`,
    `output${path_1.default.sep}expansions.xml`,
    // qa.xml contains FHIR that will only cause us issues, so we skip it
    `output${path_1.default.sep}qa.xml`,
    // These template files do not contain valid JSON. Since they are template files, we skip processing them.
    `template${path_1.default.sep}onGenerate-validation.json`,
    `template${path_1.default.sep}ongenerate-validation-igqa.json`,
    `template${path_1.default.sep}ongenerate-validation-jira.json`
];
// Certain directories are common in IG Publisher output, but don't contain any FHIR, and processing
// them will only create confusing errors, so we ignore these directories
const IGNORED_NON_RESOURCE_DIRECTORIES = [
    `input${path_1.default.sep}includes`,
    `input${path_1.default.sep}pagecontent`,
    `input${path_1.default.sep}pages`,
    `input${path_1.default.sep}intro-notes`,
    `input${path_1.default.sep}images`,
    `input${path_1.default.sep}images-source`
];
const LARGE_FILE_BUFFER_LENGTH = 200000;
//# sourceMappingURL=Processing.js.map