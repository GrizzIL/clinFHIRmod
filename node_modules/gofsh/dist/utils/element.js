"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAncestorSliceDefinition = exports.getCardinality = exports.getAncestorElement = exports.isFSHValueEmpty = exports.getFSHValue = exports.getPathValuePairs = exports.getPath = void 0;
const flat_1 = require("flat");
const lodash_1 = require("lodash");
const fsh_sushi_1 = require("fsh-sushi");
const common_1 = require("../exportable/common");
// This function depends on the id of an element to construct the path.
// Per the specification https://www.hl7.org/fhir/elementdefinition.html#id, we should
// be able to assume that id will exist and each token will have the form pathpart:slicename/reslicename
function getPath(element) {
    const FHIRtokens = element.id.split('.').slice(1);
    // If the id is for the root element (ex "Observation"), we specify that path in FSH as "."
    if (!FHIRtokens.length) {
        return '.';
    }
    const FSHtokens = [];
    FHIRtokens.forEach(FHIRtoken => {
        const [pathPart, slicePart] = FHIRtoken.split(':', 2);
        const sliceTokens = slicePart === null || slicePart === void 0 ? void 0 : slicePart.split('/');
        // If this is a sliced choice element, we use the sliceName for the path
        // value[x]:valueString -> valueString
        if (pathPart.endsWith('[x]') && (sliceTokens === null || sliceTokens === void 0 ? void 0 : sliceTokens.length)) {
            FSHtokens.push(sliceTokens[0]);
            return;
        }
        // Construct the FSHToken to be equivalent to the FHIR token but with [] for slicing and reslicing
        let FSHToken = pathPart;
        sliceTokens === null || sliceTokens === void 0 ? void 0 : sliceTokens.forEach(sliceToken => (FSHToken += `[${sliceToken}]`));
        FSHtokens.push(FSHToken);
    });
    return FSHtokens.join('.');
}
exports.getPath = getPath;
function getPathValuePairs(object) {
    const flatObject = flat_1.flatten(object);
    const flatFSHObject = {};
    Object.keys(flatObject)
        .filter(key => flatObject[key] != null)
        .forEach(key => {
        // TODO: This assumes that the values can be taken as-is, not the case for something like "code" data types
        // since they must be converted from a "foo" to "#foo"
        flatFSHObject[key.replace(/\.(\d+)([\.]|$)/g, (match, p1, p2) => `[${p1}]${p2}`)] =
            flatObject[key];
    });
    return flatFSHObject;
}
exports.getPathValuePairs = getPathValuePairs;
const typeCache = new Map();
function getFSHValue(index, flatArray, resourceType, fisher) {
    var _a, _b, _c, _d, _e, _f, _g;
    const [key, value] = flatArray[index];
    const fishingType = resourceType === 'Concept' ? 'CodeSystem' : resourceType;
    // Finding element by path works without array information and _ from children of primitives
    let pathWithoutIndex = common_1.removeUnderscoreForPrimitiveChildPath(key).replace(/\[\d+\]/g, '');
    if (resourceType === 'Concept') {
        pathWithoutIndex = `concept.${pathWithoutIndex}`;
    }
    // If we have already looked up this path for this resource, get it from cache
    const type = (_a = typeCache.get(resourceType)) === null || _a === void 0 ? void 0 : _a.get(pathWithoutIndex);
    if (type === 'code') {
        return new fsh_sushi_1.fshtypes.FshCode(value.toString());
    }
    else if (type === 'integer64') {
        return BigInt(value);
    }
    else if (type) {
        return value;
    }
    // If the path is one on an entry/contained resource, find the element on the ResourceType of the entry/contained resource
    if (pathWithoutIndex.startsWith('entry.resource.') || pathWithoutIndex.startsWith('contained.')) {
        const [, baseKey, newKey] = key.match(/^(entry\[\d+\].resource|contained\[\d+\])\.(.+)/);
        // We can safely assume that all of the paths for a given contained resource are
        // sequential in the flatArray, so find the start and end of that sequence and slice it out
        const nestedResourceStartIndex = flatArray.findIndex(([key]) => key.startsWith(baseKey));
        let nestedResourceEndIndex = nestedResourceStartIndex + 1;
        while ((_b = flatArray[nestedResourceEndIndex]) === null || _b === void 0 ? void 0 : _b[0].startsWith(baseKey)) {
            nestedResourceEndIndex++;
        }
        const subArray = flatArray
            .slice(nestedResourceStartIndex, nestedResourceEndIndex)
            .map(([key, value]) => [
            key.replace(/^(entry\[\d+\].resource|contained\[\d+\])\./, ''),
            value
        ]);
        const containedResourceType = (_c = subArray.find(([key]) => key === 'resourceType')) === null || _c === void 0 ? void 0 : _c[1];
        const newIndex = subArray.findIndex(([key]) => key === newKey);
        // Get the FSH value based on the contained resource type. Use paths relative to the contained resource.
        return getFSHValue(newIndex, subArray, containedResourceType, fisher);
    }
    if (!typeCache.has(resourceType)) {
        typeCache.set(resourceType, new Map());
    }
    const definition = fsh_sushi_1.fhirtypes.StructureDefinition.fromJSON(fisher.fishForFHIR(fishingType, fsh_sushi_1.utils.Type.Resource, fsh_sushi_1.utils.Type.Type));
    const element = definition.findElementByPath(pathWithoutIndex, fisher);
    if (((_e = (_d = element === null || element === void 0 ? void 0 : element.type) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.code) === 'code') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'code');
        return new fsh_sushi_1.fshtypes.FshCode(value.toString());
    }
    else if (((_g = (_f = element === null || element === void 0 ? void 0 : element.type) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.code) === 'integer64') {
        typeCache.get(resourceType).set(pathWithoutIndex, 'integer64');
        return BigInt(value);
    }
    typeCache.get(resourceType).set(pathWithoutIndex, typeof value);
    return value;
}
exports.getFSHValue = getFSHValue;
// Typical empty FSH values are: [], {}, null, undefined
function isFSHValueEmpty(fshValue) {
    return (lodash_1.isObject(fshValue) && lodash_1.isEmpty(fshValue)) || lodash_1.isNil(fshValue);
}
exports.isFSHValueEmpty = isFSHValueEmpty;
function getAncestorElement(id, structDef, fisher) {
    var _a, _b, _c;
    let element;
    let currentStructDef = fisher.fishForFHIR(structDef.baseDefinition);
    while (currentStructDef && !element) {
        element = (_b = (_a = currentStructDef.snapshot) === null || _a === void 0 ? void 0 : _a.element.find((el) => el.id === id)) !== null && _b !== void 0 ? _b : (_c = currentStructDef.differential) === null || _c === void 0 ? void 0 : _c.element.find((el) => el.id === id);
        currentStructDef = fisher.fishForFHIR(currentStructDef.baseDefinition);
    }
    return element !== null && element !== void 0 ? element : null;
}
exports.getAncestorElement = getAncestorElement;
function getCardinality(id, structDef, fisher) {
    var _a, _b, _c;
    let min;
    let max;
    let currentStructDef = structDef;
    while (currentStructDef && (min == null || max == null)) {
        const element = (_b = (_a = currentStructDef.snapshot) === null || _a === void 0 ? void 0 : _a.element.find((el) => el.id === id)) !== null && _b !== void 0 ? _b : (_c = currentStructDef.differential) === null || _c === void 0 ? void 0 : _c.element.find((el) => el.id === id);
        min = min !== null && min !== void 0 ? min : element === null || element === void 0 ? void 0 : element.min;
        max = max !== null && max !== void 0 ? max : element === null || element === void 0 ? void 0 : element.max;
        currentStructDef = fisher.fishForFHIR(currentStructDef.baseDefinition);
    }
    return min != null && max != null ? { min, max } : null;
}
exports.getCardinality = getCardinality;
function getAncestorSliceDefinition(element, sd, fisher) {
    // slices may be defined in various ways.
    // for example, the slice Z at path:
    // alpha[X].beta[Y].gamma[Z]
    // may be defined in any of the following ways:
    // alpha.beta.gamma[Z]
    // alpha[X].beta.gamma[Z]
    // alpha.beta[Y].gamma[Z]
    // alpha[X].beta[Y].gamma[Z]
    // we can use getAncestorElement to help us out here.
    if (element.sliceName) {
        const idParts = element.id.split('.');
        // if there are slices earlier in the id,
        // check both the slice and list element.
        const idPartVariations = [
            ...idParts.slice(0, -1).map(part => {
                if (part.indexOf(':') > -1) {
                    return [part, part.split(':')[0]];
                }
                else {
                    return [part];
                }
            }),
            idParts.slice(-1)
        ];
        // the set of ids to check is the cartesian product of all the id variations
        const idsToCheck = cartesian(...idPartVariations);
        for (const id of idsToCheck) {
            const ancestorElement = getAncestorElement(id.join('.'), sd, fisher);
            if (ancestorElement) {
                return ancestorElement;
            }
        }
    }
}
exports.getAncestorSliceDefinition = getAncestorSliceDefinition;
// adapted from https://stackoverflow.com/questions/12303989/cartesian-product-of-multiple-arrays-in-javascript#43053803
function cartesian(...sublists) {
    return sublists.reduce((prevList, curList) => {
        return lodash_1.flatMap(prevList, prevElement => {
            return curList.map(curElement => {
                return lodash_1.flatten([prevElement, curElement]);
            });
        });
    });
}
//# sourceMappingURL=element.js.map