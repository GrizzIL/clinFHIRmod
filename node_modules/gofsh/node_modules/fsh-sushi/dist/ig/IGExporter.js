"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IGExporter = void 0;
const path_1 = __importDefault(require("path"));
const ini_1 = __importDefault(require("ini"));
const os_1 = require("os");
const lodash_1 = require("lodash");
const title_case_1 = require("title-case");
const fs_extra_1 = require("fs-extra");
const junk_1 = __importDefault(require("junk"));
const utils_1 = require("../utils");
// List of Conformance and Terminology resources from http://hl7.org/fhir/R4/resourcelist.html
const CONFORMANCE_AND_TERMINOLOGY_RESOURCES = new Set([
    'CapabilityStatement',
    'StructureDefinition',
    'ImplementationGuide',
    'SearchParameter',
    'MessageDefinition',
    'OperationDefinition',
    'CompartmentDefinition',
    'StructureMap',
    'GraphDefinition',
    'ExampleScenario',
    'CodeSystem',
    'ValueSet',
    'ConceptMap',
    'NamingSystem',
    'TerminologyCapabilities'
]);
/**
 * The IG Exporter exports the FSH artifacts into a file structure supported by the IG Publisher.
 * This allows a FSH Tank to be built as a FHIR IG.  Currently, template-based IG publishing is
 * still new, so this functionality is subject to change.
 *
 * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/index.html}
 */
class IGExporter {
    constructor(pkg, fhirDefs, inputPath) {
        this.pkg = pkg;
        this.fhirDefs = fhirDefs;
        this.inputPath = inputPath;
        this.config = pkg.config;
        this.configPath = path_1.default.resolve(this.inputPath, '..', path_1.default.basename(this.config.filePath));
        this.configName = path_1.default.basename(this.configPath);
    }
    /**
     * Export the IG structure to the location specified by the outPath argument
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#directory-structure}
     * @param outPath {string} - the path to export the IG file structure to
     */
    export(outPath) {
        var _a;
        fs_extra_1.ensureDirSync(outPath);
        this.initIG();
        this.addResources();
        this.addPredefinedResources();
        this.addConfiguredResources();
        this.addConfiguredGroups();
        this.addIndex(outPath);
        if (!((_a = this.config.pages) === null || _a === void 0 ? void 0 : _a.length)) {
            this.addOtherPageContent();
        }
        else {
            this.addConfiguredPageContent();
        }
        this.addMenuXML(outPath);
        this.checkIgIni();
        this.checkPackageList();
        this.addImplementationGuide(outPath);
    }
    /**
     * Initializes the ImplementationGuide JSON w/ data from the configuration YAML
     *
     * @see {@link https://confluence.hl7.org/pages/viewpage.action?pageId=35718629#NPMPackageSpecification-PackageManifestpropertiesforIGs}
     */
    initIG() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // first, properties that can be directly used without much trouble
        this.ig = {
            resourceType: 'ImplementationGuide',
            id: this.config.id,
            meta: this.config.meta,
            implicitRules: this.config.implicitRules,
            language: this.config.language,
            text: this.config.text,
            contained: this.config.contained,
            extension: this.config.extension,
            modifierExtension: this.config.modifierExtension,
            url: (_a = this.config.url) !== null && _a !== void 0 ? _a : `${this.config.canonical}/ImplementationGuide/${this.config.id}`,
            version: this.config.version,
            // name must be alphanumeric (allowing underscore as well)
            name: this.config.name.replace(/[^A-Za-z0-9_]/g, ''),
            title: this.config.title,
            status: this.config.status,
            experimental: this.config.experimental,
            date: this.config.date,
            publisher: this.config.publisher,
            contact: this.config.contact,
            description: this.config.description,
            useContext: this.config.useContext,
            jurisdiction: this.config.jurisdiction,
            copyright: this.config.copyright,
            packageId: (_b = this.config.packageId) !== null && _b !== void 0 ? _b : this.config.id,
            license: this.config.license,
            fhirVersion: this.config.fhirVersion,
            // put an empty dependsOn here to preserve the location of this property (delete later if not needed)
            dependsOn: [],
            global: this.config.global,
            definition: {
                // put an empty grouping here to preserve the location of this property (delete later if not needed)
                grouping: [],
                resource: [],
                page: {
                    nameUrl: 'toc.html',
                    title: 'Table of Contents',
                    generation: 'html',
                    page: [] // index.[md|html] is required and added later
                },
                // required parameters are enforced in the configuration
                // default to empty array in case we want to add other parameters later
                parameter: (_c = this.config.parameters) !== null && _c !== void 0 ? _c : [],
                template: this.config.templates
            }
        };
        // Add the path-history, if applicable (only applies to HL7 IGs)
        if (/^https?:\/\/hl7.org\//.test(this.config.canonical) &&
            !this.ig.definition.parameter.some(param => {
                return param.code === 'path-history';
            })) {
            this.ig.definition.parameter.push({
                code: 'path-history',
                value: `${this.config.canonical}/history.html`
            });
        }
        // Default 'autoload-resources' to false if it is not already defined
        // and only if custom resources are defined. This is done to counter
        // the IG Publisher behaving as if 'autoload-resources' is set to true
        // and allowing the IG Publisher to attempt processing of custom resources.
        if (((_d = this.pkg.resources) === null || _d === void 0 ? void 0 : _d.length) > 0 &&
            !this.ig.definition.parameter.some(param => {
                return param.code === 'autoload-resources';
            })) {
            this.ig.definition.parameter.push({
                code: 'autoload-resources',
                value: 'false'
            });
            utils_1.logger.info('The autoload-resources parameter has been set to false because this implementation guide contains custom resources.');
        }
        // add dependencies, filtering out "virtual" extension packages
        const dependencies = (_e = this.config.dependencies) === null || _e === void 0 ? void 0 : _e.filter(d => !/^hl7\.fhir\.extensions\.r[2345]$/.test(d.packageId));
        if (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length) {
            const igs = this.fhirDefs.allImplementationGuides();
            for (const dependency of dependencies) {
                const dependsEntry = this.fixDependsOn(dependency, igs);
                if (dependsEntry) {
                    this.ig.dependsOn.push(dependsEntry);
                }
            }
        }
        else {
            delete this.ig.dependsOn;
        }
        // delete grouping value if there are no groups in the config
        if (!((_f = this.config.groups) === null || _f === void 0 ? void 0 : _f.length) && !((_g = this.config.resources) === null || _g === void 0 ? void 0 : _g.some(r => r.groupingId != null))) {
            delete this.ig.definition.grouping;
        }
        // delete global if it is empty
        if (!((_h = this.config.global) === null || _h === void 0 ? void 0 : _h.length)) {
            delete this.ig.global;
        }
        // delete templates if it is empty
        if (!((_j = this.config.templates) === null || _j === void 0 ? void 0 : _j.length)) {
            delete this.ig.definition.template;
        }
    }
    /**
     * Fixes a dependsOn entry by specifying its uri (if not yet specified) and generating an id (if
     * not yet specified). Will also ensure that required properties (uri/version) are available.
     * If it cannot ensure a valid dependsOn entry, it will return undefined.
     * @param dependency - the dependency to fix
     * @param igs - the IGs to search when finding the dependency URI
     * @returns the fixed dependency or null if it can't be fixed
     */
    fixDependsOn(dependency, igs) {
        // Clone it so we don't mutate the original
        const dependsOn = lodash_1.cloneDeep(dependency);
        if (dependsOn.version == null) {
            // No need for the detailed log message since we already logged one in the package loader.
            utils_1.logger.error(`Failed to add ${dependency.packageId} to ImplementationGuide instance because no ` +
                `version was specified in your ${this.configName}.`);
            return;
        }
        if (dependsOn.uri == null) {
            // Need to find the URI from the IG in the FHIR cache
            const dependencyIG = igs.find(ig => ig.packageId === dependsOn.packageId &&
                (ig.version === dependsOn.version ||
                    'current' === dependsOn.version ||
                    'dev' === dependsOn.version));
            dependsOn.uri = dependencyIG === null || dependencyIG === void 0 ? void 0 : dependencyIG.url;
            if (dependsOn.uri == null) {
                utils_1.logger.error(`Failed to add ${dependsOn.packageId}:${dependsOn.version} to ` +
                    'ImplementationGuide instance because SUSHI could not find the IG URL in the ' +
                    `dependency IG. To specify the IG URL in your ${this.configName}, use the dependency ` +
                    'details format:\n\n' +
                    'dependencies:\n' +
                    `  ${dependsOn.packageId}:\n` +
                    '    uri: http://my-fhir-ig.org/ImplementationGuide/123\n' +
                    `    version: ${dependsOn.version}`);
                return;
            }
        }
        if (dependsOn.id == null) {
            // packageId should be "a..z, A..Z, 0..9, and _ and it must start with a..z | A..Z" per
            // https://chat.fhir.org/#narrow/stream/215610-shorthand/topic/SUSHI.200.2E12.2E7/near/199193333
            // depId should be [A-Za-z0-9\-\.]{1,64}, so we replace . and - with _ and prepend "id_" if it does not start w/ a-z|A-Z
            dependsOn.id = /[A-Za-z]/.test(dependsOn.packageId[0])
                ? dependsOn.packageId.replace(/\.|-/g, '_')
                : 'id_' + dependsOn.packageId.replace(/\.|-/g, '_');
        }
        return dependsOn;
    }
    /**
     * Add the index.md file. Creates an index.md based on the "indexPageContent" in sushi-config.yaml.
     * If the user provided an index file, and no "indexPageContent" in sushi-config.yaml is specified,
     * the provided file is used instead. The provided file may be in one of two locations:
     * ./input/pagecontent or ./input/pages
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     * @param igPath - the path where the IG is exported to
     */
    addIndex(igPath) {
        var _a;
        const pageContentExportPath = path_1.default.join(igPath, 'input', 'pagecontent');
        // If the user provided an index.md file, use that
        // There are four possible locations for it (two filenames in two directories)
        // If more possibilities arise, rewrite this to avoid having to list all of them
        const inputIndexMarkdownPageContentPath = path_1.default.join(this.inputPath, 'input', 'pagecontent', 'index.md');
        const inputIndexXMLPageContentPath = path_1.default.join(this.inputPath, 'input', 'pagecontent', 'index.xml');
        const inputIndexMarkdownPagesPath = path_1.default.join(this.inputPath, 'input', 'pages', 'index.md');
        const inputIndexXMLPagesPath = path_1.default.join(this.inputPath, 'input', 'pages', 'index.xml');
        let generation = 'markdown';
        let filePath;
        if (fs_extra_1.existsSync(inputIndexMarkdownPageContentPath))
            filePath = inputIndexMarkdownPageContentPath;
        if (fs_extra_1.existsSync(inputIndexXMLPageContentPath))
            filePath = inputIndexXMLPageContentPath;
        if (fs_extra_1.existsSync(inputIndexMarkdownPagesPath))
            filePath = inputIndexMarkdownPagesPath;
        if (fs_extra_1.existsSync(inputIndexXMLPagesPath))
            filePath = inputIndexXMLPagesPath;
        if (this.config.indexPageContent) {
            fs_extra_1.ensureDirSync(pageContentExportPath);
            if (filePath) {
                const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), path_1.default.relative(this.inputPath, filePath));
                const preferredFileMessage = `Since a ${filePathString} file was found, the "indexPageContent" property in the ${this.configName} ` +
                    'will be ignored and an index.md file will not be generated. Remove the "indexPageContent" ' +
                    `property in ${this.configName} to resolve this warning.`;
                utils_1.logger.warn(`Found both an "indexPageContent" property in ${this.configName} and an index file at ` +
                    `${filePathString}. ${preferredFileMessage}`, {
                    file: filePath
                });
                if (!fs_extra_1.existsSync(inputIndexMarkdownPagesPath) &&
                    !fs_extra_1.existsSync(inputIndexMarkdownPageContentPath) &&
                    (fs_extra_1.existsSync(inputIndexXMLPagesPath) || fs_extra_1.existsSync(inputIndexXMLPageContentPath))) {
                    generation = 'html';
                }
                // Add user-provided index file to IG definition
                this.ig.definition.page.page.push({
                    nameUrl: 'index.html',
                    title: 'Home',
                    generation
                });
                return;
            }
            // Generate index file if indexPageContent is provided in config
            const filePathString = 'input';
            const warning = warningBlock('<!-- index.md {% comment %}', '{% endcomment %} -->', [
                `To change the contents of this file, edit the "indexPageContent" attribute in the tank ${this.configName} file`,
                `or provide your own index file in the ${filePathString}${path_1.default.sep}pagecontent or ${filePathString}${path_1.default.sep}pages folder.`,
                'See: https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input'
            ]);
            const outputPath = path_1.default.join(pageContentExportPath, 'index.md');
            fs_extra_1.outputFileSync(outputPath, `${warning}${this.config.indexPageContent}`);
            utils_1.logger.info(`Generated index.md based on "indexPageContent" in ${this.configName}.`);
        }
        else if (!fs_extra_1.existsSync(inputIndexMarkdownPagesPath) &&
            !fs_extra_1.existsSync(inputIndexMarkdownPageContentPath) &&
            (fs_extra_1.existsSync(inputIndexXMLPagesPath) || fs_extra_1.existsSync(inputIndexXMLPageContentPath))) {
            generation = 'html';
        }
        else {
            // do nothing -- no indexPageContent in config, do nothing with index file if provided
        }
        // Add user-provided or generated index file to IG definition
        // If pages are defined in the configuration, this is the author's responsibility
        if (!((_a = this.config.pages) === null || _a === void 0 ? void 0 : _a.length) && (filePath || this.config.indexPageContent)) {
            this.ig.definition.page.page.push({
                nameUrl: 'index.html',
                title: 'Home',
                generation
            });
        }
    }
    /**
     * Adds additional pages beyond index.md that are defined by the user.
     * Only add formats that are supported by the IG template
     * Intro and notes file contents are injected into relevant pages and should not be treated as their own page
     * Three directories are checked for additional page content:
     * pagecontent, pages, and resource-docs
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     */
    addOtherPageContent() {
        const pageContentFolderNames = ['pagecontent', 'pages', 'resource-docs'];
        for (const contentFolder of pageContentFolderNames) {
            const inputPageContentPath = path_1.default.join(this.inputPath, 'input', contentFolder);
            if (fs_extra_1.existsSync(inputPageContentPath)) {
                const organizedPages = this.organizePageContent(fs_extra_1.readdirSync(inputPageContentPath));
                let invalidFileTypeIncluded = false;
                organizedPages.forEach(page => {
                    // All user defined pages are included in input/${contentFolder}
                    const pagePath = path_1.default.join(this.inputPath, 'input', contentFolder, page.originalName);
                    const isSupportedFileType = page.fileType === 'md' || page.fileType === 'xml';
                    const isIntroOrNotesFile = page.name.endsWith('-intro') || page.name.endsWith('-notes');
                    if (isSupportedFileType) {
                        // Intro and notes files will be in supported formats but are not separate pages, so they should not be added to IG definition
                        if (!isIntroOrNotesFile) {
                            // Valid page files will be added to the IG definition
                            this.ig.definition.page.page.push({
                                nameUrl: `${page.name}.html`,
                                title: page.title,
                                generation: page.fileType === 'md' ? 'markdown' : 'html'
                            });
                        }
                    }
                    else if (!junk_1.default.is(path_1.default.basename(pagePath))) {
                        invalidFileTypeIncluded = true;
                    }
                });
                if (invalidFileTypeIncluded) {
                    const errorString = 'Files not in the supported file types (.md and .xml) were detected.';
                    utils_1.logger.warn(errorString, {
                        file: inputPageContentPath
                    });
                }
            }
        }
    }
    /**
     * Adds additional pages to the IG based on user configuration.
     * Only pages present in the configuration are added, regardless of available files.
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#directory-structure}
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     */
    addConfiguredPageContent() {
        // only configured pages are added to the implementation guide,
        for (const page of this.config.pages) {
            this.addConfiguredPage(page, this.ig.definition.page.page);
        }
        // all files in page content folders are left alone but checked for supported file types
        const pageContentFolderNames = ['pagecontent', 'pages', 'resource-docs'];
        for (const contentFolder of pageContentFolderNames) {
            let invalidFileTypeIncluded = false;
            const inputPageContentPath = path_1.default.join(this.inputPath, 'input', contentFolder);
            if (fs_extra_1.existsSync(inputPageContentPath)) {
                for (const contentFile of fs_extra_1.readdirSync(inputPageContentPath)) {
                    const fileType = contentFile.slice(contentFile.lastIndexOf('.') + 1);
                    if (!(fileType === 'md' || fileType === 'xml') && !junk_1.default.is(path_1.default.basename(contentFile))) {
                        invalidFileTypeIncluded = true;
                    }
                }
            }
            if (invalidFileTypeIncluded) {
                const errorString = 'Files not in the supported file types (.md and .xml) were detected. These files will be included without any processing.';
                utils_1.logger.warn(errorString, {
                    file: inputPageContentPath
                });
            }
        }
    }
    /**
     * Adds pages to the implementation guide's list of pages.
     * The page configuration is traversed recursively to maintain the configured structure.
     *
     * @see {@link https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input}
     * @param {ImplementationGuideDefinitionPage} page - the current page being added to a list of output pages
     * @param {ImplementationGuideDefinitionPage[]} target - the list of output pages that will receive the current page
     */
    addConfiguredPage(page, target) {
        var _a, _b, _c;
        if (page.nameUrl) {
            const lastPeriod = page.nameUrl.lastIndexOf('.');
            let name, fileType = '';
            if (lastPeriod === -1) {
                name = page.nameUrl;
            }
            else {
                name = page.nameUrl.slice(0, lastPeriod);
                fileType = page.nameUrl.slice(lastPeriod + 1);
            }
            // Any page listed in configuration will be added, even if it does not exist.
            const igPage = {
                nameUrl: `${name}.html`,
                title: (_a = page.title) !== null && _a !== void 0 ? _a : title_case_1.titleCase(lodash_1.words(name).join(' ')),
                generation: (_b = page.generation) !== null && _b !== void 0 ? _b : (fileType === 'md' ? 'markdown' : 'html')
            };
            if ((_c = page.page) === null || _c === void 0 ? void 0 : _c.length) {
                const igSubpages = [];
                for (const subpage of page.page) {
                    this.addConfiguredPage(subpage, igSubpages);
                }
                if (igSubpages.length > 0) {
                    igPage.page = igSubpages;
                }
            }
            target.push(igPage);
        }
    }
    /**
     * Sorts and renames pages based on numeric prefixes.
     * Numeric prefixes are used for applying a sort order, and remain part of the file name.
     *
     * @param {string[]} pages - list of file names with extensions
     * @returns {PageMetadata []} - sorted list of file information objects
     */
    organizePageContent(pages) {
        // Remove any preexisting duplicate file names, and log an error
        pages = pages.filter(page => {
            if (pages.find(p => p.slice(0, p.lastIndexOf('.')) === page.slice(0, page.lastIndexOf('.'))) !==
                page) {
                utils_1.logger.error(`Duplicate file ${page} will be ignored. Please rename to avoid collisions.`, {
                    file: page
                });
                return false;
            }
            return true;
        });
        const pageData = pages.map(page => {
            const nameParts = page.match(/^(\d+)_(.*)/);
            let prefix = null;
            let nameWithoutPrefix;
            const nameWithPrefix = page.slice(0, page.lastIndexOf('.'));
            if (nameParts == null) {
                nameWithoutPrefix = page.slice(0, page.lastIndexOf('.'));
            }
            else {
                prefix = parseInt(nameParts[1]);
                nameWithoutPrefix = nameParts[2].slice(0, nameParts[2].lastIndexOf('.'));
            }
            return {
                originalName: page,
                prefix: prefix,
                name: nameWithPrefix,
                title: title_case_1.titleCase(lodash_1.words(nameWithoutPrefix).join(' ')),
                fileType: page.slice(page.lastIndexOf('.') + 1)
            };
        });
        let mightHaveDuplicates = true;
        while (mightHaveDuplicates) {
            mightHaveDuplicates = false;
            pageData.forEach(page => {
                const sameName = pageData.filter(otherPage => otherPage.name == page.name);
                if (sameName.length > 1) {
                    mightHaveDuplicates = true;
                    sameName.forEach(matchingPage => {
                        matchingPage.name = matchingPage.originalName.slice(0, matchingPage.originalName.lastIndexOf('.'));
                    });
                }
            });
        }
        return pageData.filter(page => page.name !== 'index').sort(this.compareIgFilenames);
    }
    /**
     * Compares two file names, each of which may be prefixed with a number.
     * If neither file has a prefix, compares the file names alphabetically.
     * If one file has a prefix, that file is before the other.
     * If both have a prefix, compares the prefixes numerically.
     * If the prefixes are equal, resolves the tie by comparing the file names alphabetically.
     *
     * @param {PageMetadata} pageA - metadata for first file
     * @param {PageMetadata} pageB - metadata for second file
     * @returns {number} - positive when file b comes first, negative when file a comes first, zero when the file names are equal.
     */
    compareIgFilenames(pageA, pageB) {
        if (pageA.prefix == null && pageB.prefix == null) {
            return pageA.name.localeCompare(pageB.name);
        }
        else if (pageA.prefix == null) {
            return 1;
        }
        else if (pageB.prefix == null) {
            return -1;
        }
        else {
            const prefixComparison = pageA.prefix - pageB.prefix;
            if (prefixComparison == 0) {
                return pageA.name.localeCompare(pageB.name);
            }
            else {
                return prefixComparison;
            }
        }
    }
    /**
     * Adds menu.xml
     * A user can define a menu in sushi-config.yaml or provide one in ./input/includes.
     * If neither is provided, the static one SUSHI provides will be used.
     *
     * @param {string} igPath - the path where the IG is exported to
     */
    addMenuXML(igPath) {
        const menuXMLDefaultPath = path_1.default.join(this.inputPath, 'input', 'includes', 'menu.xml');
        const menuXMLOutputPath = path_1.default.join(igPath, 'fsh-generated', 'includes', 'menu.xml');
        // If user provided file and config, log a warning but prefer the config.
        if (fs_extra_1.existsSync(menuXMLDefaultPath) && this.config.menu) {
            const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), 'input', 'includes', 'menu.xml');
            const preferredFileMessage = `Since a ${filePathString} file was found, the "menu" property in the ${this.configName} ` +
                `will be ignored and a menu.xml file will not be generated. Remove the ${filePathString} ` +
                `file to use the "menu" property in ${this.configName} to generate a menu.xml file instead.`;
            utils_1.logger.warn(`Found both a "menu" property in ${this.configName} and a menu.xml file at ${filePathString}. ` +
                `${preferredFileMessage}`, {
                file: menuXMLDefaultPath
            });
            return;
        }
        // Always use config menu if defined
        if (this.config.menu) {
            let menu = `<ul xmlns="http://www.w3.org/1999/xhtml" class="nav navbar-nav">${os_1.EOL}`;
            this.config.menu.forEach(item => {
                menu += this.buildMenuItem(item, 2);
            });
            menu += '</ul>';
            const filePathString = path_1.default.join('input', 'includes');
            const warning = warningBlock(`<!-- ${path_1.default.parse(menuXMLOutputPath).base} {% comment %}`, '{% endcomment %} -->', [
                `To change the contents of this file, edit the "menu" attribute in the tank ${this.configName} file`,
                `or provide your own menu.xml in the ${filePathString} folder`
            ]);
            fs_extra_1.outputFileSync(menuXMLOutputPath, `${warning}${menu}`, 'utf8');
        }
    }
    /**
     * Build individual menu item for menu.xml file. An item could contain a submenu
     *
     * @param {ConfigurationMenuItem} item - the menu item to be rendered
     * @param {number} spaces - the base number of spaces to indent
     * @returns {string} - the piece of XML relating to the given menu item
     */
    buildMenuItem(item, spaces) {
        const prefixSpaces = ' '.repeat(spaces);
        let menuItem = '';
        if (item.subMenu) {
            menuItem += `${prefixSpaces}<li class="dropdown">${os_1.EOL}`;
            menuItem += this.buildSubMenu(item, spaces + 2);
            menuItem += `${prefixSpaces}</li>${os_1.EOL}`;
        }
        else {
            menuItem += `${prefixSpaces}<li>${os_1.EOL}${prefixSpaces}${'  '}`;
            if (item.url) {
                menuItem += '<a ';
                if (item.openInNewTab)
                    menuItem += 'target="_blank" ';
                menuItem += `href="${item.url}">`;
            }
            menuItem += item.name;
            if (item.url) {
                menuItem += '</a>';
            }
            menuItem += `${os_1.EOL}${prefixSpaces}</li>${os_1.EOL}`;
        }
        return menuItem;
    }
    /**
     * Build a submenu for an item for menu.xml.
     *
     * @param item - the menu item with submenu to be rendered
     * @param spaces - the base number of spaces to indent
     * @returns {string} - the piece of XML relating to the submenu
     */
    buildSubMenu(item, spaces) {
        var _a;
        const prefixSpaces = ' '.repeat(spaces);
        let subMenu = `${prefixSpaces}<a data-toggle="dropdown" href="#" class="dropdown-toggle">${item.name}${os_1.EOL}`;
        subMenu += `${prefixSpaces}${'  '}<b class="caret"></b>${os_1.EOL}`;
        subMenu += `${prefixSpaces}</a>${os_1.EOL}`;
        subMenu += `${prefixSpaces}<ul class="dropdown-menu">${os_1.EOL}`;
        (_a = item.subMenu) === null || _a === void 0 ? void 0 : _a.forEach((subItem) => {
            if (subItem.subMenu) {
                utils_1.logger.warn(`The ${subItem.name} menu item specifies a sub-menu. The IG template currently only supports two levels of menus. ` +
                    `The sub-menu for ${subItem.name} is included in the menu.xml file but it will not be rendered in the IG.`);
            }
            subMenu += this.buildMenuItem(subItem, spaces + 2);
        });
        subMenu += `${prefixSpaces}</ul>${os_1.EOL}`;
        return subMenu;
    }
    /**
     * Add each of the resources from the package to the ImplementationGuide JSON file.
     * Configuration may specify resources to omit.
     *
     * This function has similar operation to addPredefinedResources, and both should be
     * analyzed when making changes to either.
     */
    addResources() {
        // NOTE: Custom resources are not included in the implementation guide
        //       because the IG Publisher will not except newly defined resources.
        //       This only prevents adding custom resources into the IG. It does
        //       NOT prevent custom resource StructureDefinitions from being
        //       written to disk.
        const resources = [
            ...lodash_1.sortBy(this.pkg.profiles, sd => sd.name),
            ...lodash_1.sortBy(this.pkg.extensions, sd => sd.name),
            ...lodash_1.sortBy(this.pkg.logicals, sd => sd.name),
            ...lodash_1.sortBy(this.pkg.valueSets, valueSet => valueSet.name),
            ...lodash_1.sortBy(this.pkg.codeSystems, codeSystem => codeSystem.name)
        ];
        resources.forEach(r => {
            var _a, _b, _c, _d, _e, _f;
            const referenceKey = `${r.resourceType}/${r.id}`;
            const newResource = {
                reference: { reference: referenceKey }
            };
            const configResource = ((_a = this.config.resources) !== null && _a !== void 0 ? _a : []).find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) == referenceKey; });
            if ((configResource === null || configResource === void 0 ? void 0 : configResource.omit) !== true) {
                newResource.name = (_d = (_c = (_b = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _b !== void 0 ? _b : r.title) !== null && _c !== void 0 ? _c : r.name) !== null && _d !== void 0 ? _d : r.id;
                newResource.description = (_e = configResource === null || configResource === void 0 ? void 0 : configResource.description) !== null && _e !== void 0 ? _e : r.description;
                if ((_f = configResource === null || configResource === void 0 ? void 0 : configResource.fhirVersion) === null || _f === void 0 ? void 0 : _f.length) {
                    newResource.fhirVersion = configResource.fhirVersion;
                }
                if (configResource === null || configResource === void 0 ? void 0 : configResource.groupingId) {
                    newResource.groupingId = configResource.groupingId;
                    this.addGroup(newResource.groupingId);
                }
                if (configResource === null || configResource === void 0 ? void 0 : configResource.exampleCanonical) {
                    newResource.exampleCanonical = configResource.exampleCanonical;
                }
                else if (typeof (configResource === null || configResource === void 0 ? void 0 : configResource.exampleBoolean) === 'boolean') {
                    newResource.exampleBoolean = configResource.exampleBoolean;
                }
                else {
                    newResource.exampleBoolean = false;
                }
                this.ig.definition.resource.push(newResource);
            }
        });
        const instances = lodash_1.sortBy(this.pkg.instances, instance => { var _a; return (_a = instance.id) !== null && _a !== void 0 ? _a : instance._instanceMeta.name; });
        instances
            .filter(instance => instance._instanceMeta.usage !== 'Inline')
            .forEach(instance => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const referenceKey = `${instance.resourceType}/${(_a = instance.id) !== null && _a !== void 0 ? _a : instance._instanceMeta.name}`;
            const newResource = {
                reference: { reference: referenceKey }
            };
            const configResource = ((_b = this.config.resources) !== null && _b !== void 0 ? _b : []).find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) == referenceKey; });
            if ((configResource === null || configResource === void 0 ? void 0 : configResource.omit) !== true) {
                newResource.name = (_d = (_c = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _c !== void 0 ? _c : instance._instanceMeta.title) !== null && _d !== void 0 ? _d : instance._instanceMeta.name;
                newResource.description = (_e = configResource === null || configResource === void 0 ? void 0 : configResource.description) !== null && _e !== void 0 ? _e : instance._instanceMeta.description;
                if ((_f = configResource === null || configResource === void 0 ? void 0 : configResource.fhirVersion) === null || _f === void 0 ? void 0 : _f.length) {
                    newResource.fhirVersion = configResource.fhirVersion;
                }
                if (configResource === null || configResource === void 0 ? void 0 : configResource.groupingId) {
                    newResource.groupingId = configResource.groupingId;
                    this.addGroup(newResource.groupingId);
                }
                if (configResource === null || configResource === void 0 ? void 0 : configResource.exampleCanonical) {
                    newResource.exampleCanonical = configResource.exampleCanonical;
                }
                else if (typeof (configResource === null || configResource === void 0 ? void 0 : configResource.exampleBoolean) === 'boolean') {
                    newResource.exampleBoolean = configResource.exampleBoolean;
                }
                else {
                    if (instance._instanceMeta.usage === 'Example') {
                        const exampleUrl = (_h = (_g = instance.meta) === null || _g === void 0 ? void 0 : _g.profile) === null || _h === void 0 ? void 0 : _h.find(url => this.pkg.fish(url, utils_1.Type.Profile));
                        if (exampleUrl) {
                            newResource.exampleCanonical = exampleUrl;
                        }
                        else {
                            newResource.exampleBoolean = true;
                        }
                    }
                    else {
                        newResource.exampleBoolean = false;
                    }
                }
                this.ig.definition.resource.push(newResource);
            }
        });
    }
    /**
     * Adds any user provided resource files to the ImplementationGuide JSON file.
     * This includes definitions in:
     * capabilities, extensions, models, operations, profiles, resources, vocabulary, examples
     * Based on: https://build.fhir.org/ig/FHIR/ig-guidance/using-templates.html#root.input
     *
     * NOTE: This does not include files nested in subfolders in supported paths since the
     * IG Exporter does not handle those well.
     *
     * This function has similar operation to addResources, and both should be
     * analyzed when making changes to either.
     */
    addPredefinedResources() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        // Similar code for loading custom resources exists in load.ts loadCustomResources()
        const pathEnds = [
            'capabilities',
            'extensions',
            'models',
            'operations',
            'profiles',
            'resources',
            'vocabulary',
            'examples'
        ];
        const deeplyNestedFiles = [];
        for (const pathEnd of pathEnds) {
            const dirPath = path_1.default.resolve(this.inputPath, 'input', pathEnd);
            if (fs_extra_1.existsSync(dirPath)) {
                const files = utils_1.getFilesRecursive(dirPath);
                for (const file of files) {
                    if (path_1.default.dirname(file) !== dirPath) {
                        deeplyNestedFiles.push(file);
                        continue;
                    }
                    const resourceJSON = this.fhirDefs.getPredefinedResource(file);
                    if (resourceJSON) {
                        if (resourceJSON.resourceType == null || resourceJSON.id == null) {
                            utils_1.logger.error(`Resource at ${file} must define resourceType and id.`);
                            continue;
                        }
                        const referenceKey = `${resourceJSON.resourceType}/${resourceJSON.id}`;
                        const newResource = {
                            reference: {
                                reference: referenceKey
                            }
                        };
                        const configResource = ((_a = this.config.resources) !== null && _a !== void 0 ? _a : []).find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) == referenceKey; });
                        // For predefined examples of Logical Models, the user must provide an entry in config
                        // that specifies the reference as Binary/[id], the extension that specifies the resource format,
                        // and the exampleCanonical that references the LogicalModel the resource is an example of.
                        // In that case, we do not want to add our own entry for the predefined resource - we just
                        // want to use the resource entry from the sushi-config.yaml
                        const hasBinaryExampleReference = ((_b = this.config.resources) !== null && _b !== void 0 ? _b : []).some(resource => {
                            var _a, _b;
                            return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === `Binary/${resourceJSON.id}` &&
                                resource.exampleCanonical ===
                                    `${this.config.canonical}/StructureDefinition/${resourceJSON.resourceType}` && ((_b = resource.extension) === null || _b === void 0 ? void 0 : _b.some(e => e.url ===
                                'http://hl7.org/fhir/StructureDefinition/implementationguide-resource-format'));
                        });
                        if ((configResource === null || configResource === void 0 ? void 0 : configResource.omit) !== true && !hasBinaryExampleReference) {
                            const existingIndex = this.ig.definition.resource.findIndex(r => r.reference.reference === referenceKey);
                            // If the user has provided a resource, it should override the generated resource.
                            // This can be helpful for working around cases where the generated resource has some incorrect values.
                            const existingResource = existingIndex >= 0 ? this.ig.definition.resource[existingIndex] : null;
                            const existingIsExample = (existingResource === null || existingResource === void 0 ? void 0 : existingResource.exampleBoolean) || (existingResource === null || existingResource === void 0 ? void 0 : existingResource.exampleCanonical);
                            const existingName = existingIsExample ? existingResource.name : null;
                            const existingDescription = existingIsExample ? existingResource.description : null;
                            const metaExtensionDescription = this.getMetaExtensionDescription(resourceJSON);
                            const metaExtensionName = this.getMetaExtensionName(resourceJSON);
                            newResource.description = (_e = (_d = (_c = configResource === null || configResource === void 0 ? void 0 : configResource.description) !== null && _c !== void 0 ? _c : metaExtensionDescription) !== null && _d !== void 0 ? _d : existingDescription) !== null && _e !== void 0 ? _e : (CONFORMANCE_AND_TERMINOLOGY_RESOURCES.has(resourceJSON.resourceType)
                                ? resourceJSON.description
                                : undefined);
                            if (configResource === null || configResource === void 0 ? void 0 : configResource.fhirVersion) {
                                newResource.fhirVersion = configResource.fhirVersion;
                            }
                            if (configResource === null || configResource === void 0 ? void 0 : configResource.groupingId) {
                                newResource.groupingId = configResource.groupingId;
                                this.addGroup(newResource.groupingId);
                            }
                            if (pathEnd === 'examples') {
                                newResource.name = (_h = (_g = (_f = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _f !== void 0 ? _f : metaExtensionName) !== null && _g !== void 0 ? _g : existingName) !== null && _h !== void 0 ? _h : resourceJSON.id;
                                // set exampleCanonical or exampleBoolean, preferring configured values
                                if (configResource === null || configResource === void 0 ? void 0 : configResource.exampleCanonical) {
                                    newResource.exampleCanonical = configResource.exampleCanonical;
                                }
                                else if (typeof (configResource === null || configResource === void 0 ? void 0 : configResource.exampleBoolean) === 'boolean') {
                                    newResource.exampleBoolean = configResource.exampleBoolean;
                                }
                                else {
                                    const exampleUrl = (_k = (_j = resourceJSON.meta) === null || _j === void 0 ? void 0 : _j.profile) === null || _k === void 0 ? void 0 : _k.find(url => { var _a; return (_a = this.pkg.fish(url, utils_1.Type.Profile)) !== null && _a !== void 0 ? _a : this.fhirDefs.fishForFHIR(url, utils_1.Type.Profile); });
                                    if (exampleUrl) {
                                        newResource.exampleCanonical = exampleUrl;
                                    }
                                    else {
                                        newResource.exampleBoolean = true;
                                    }
                                }
                            }
                            else {
                                if (configResource === null || configResource === void 0 ? void 0 : configResource.exampleCanonical) {
                                    newResource.exampleCanonical = configResource.exampleCanonical;
                                }
                                else if (typeof (configResource === null || configResource === void 0 ? void 0 : configResource.exampleBoolean) === 'boolean') {
                                    newResource.exampleBoolean = configResource.exampleBoolean;
                                }
                                else {
                                    newResource.exampleBoolean = false;
                                }
                                // On some resources (Patient for example) these fields can be objects, avoid using them when this is true
                                const title = typeof resourceJSON.title === 'string' ? resourceJSON.title : null;
                                const name = typeof resourceJSON.name === 'string' ? resourceJSON.name : null;
                                newResource.name = (_q = (_p = (_o = (_m = (_l = configResource === null || configResource === void 0 ? void 0 : configResource.name) !== null && _l !== void 0 ? _l : metaExtensionName) !== null && _m !== void 0 ? _m : existingResource === null || existingResource === void 0 ? void 0 : existingResource.name) !== null && _o !== void 0 ? _o : title) !== null && _p !== void 0 ? _p : name) !== null && _q !== void 0 ? _q : resourceJSON.id;
                            }
                            if (existingIndex >= 0) {
                                this.ig.definition.resource[existingIndex] = newResource;
                            }
                            else {
                                this.ig.definition.resource.push(newResource);
                            }
                        }
                    }
                }
            }
        }
        if (deeplyNestedFiles.length) {
            utils_1.logger.warn('The following files were not added to the ImplementationGuide JSON because they are nested too deep. While ' +
                'SUSHI supports these paths, the IG Publisher does not. To fix this, move these files so they are directly ' +
                `under a supported input folder (e.g., input/resources, input/profiles, etc.):\n  - ${deeplyNestedFiles.join('\n  - ')}`);
        }
    }
    /**
     * Adds resources that are present only in the configuration.
     * If a configured resource is already in the implementation guide,
     * there is no need to add it again.
     */
    addConfiguredResources() {
        var _a;
        for (const resource of (_a = this.config.resources) !== null && _a !== void 0 ? _a : []) {
            if (!resource.omit &&
                this.ig.definition.resource.findIndex(r => { var _a, _b; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === ((_b = r.reference) === null || _b === void 0 ? void 0 : _b.reference); }) === -1) {
                this.ig.definition.resource.push(resource);
            }
        }
    }
    /**
     * Adds or updates a group in the implementation guide.
     *
     * @param {string} id - unique identifier for group
     * @param {string} name - name of the group
     * @param {string} description - optional description of the group
     */
    addGroup(id, name, description) {
        if (!this.ig.definition.grouping) {
            this.ig.definition.grouping = [];
        }
        // Initially `name` and `id` were derived from the same parameter. This allows
        // the function to still work with just a single parameter.
        if (name === undefined) {
            name = id;
        }
        const existingGroup = this.ig.definition.grouping.find(group => group.id === id);
        if (existingGroup) {
            existingGroup.name = name;
            if (description) {
                existingGroup.description = description;
            }
        }
        else {
            this.ig.definition.grouping.push(Object.assign({ id: id, name: name }, (description && { description })));
        }
    }
    /**
     * Adds groups listed in the configuration to the implementation guide.
     * Updates the groupingId on resources listed as members of a group.
     * Shows errors if a listed resource does not exist, or if there are conflicting
     * configured values for groupingId.
     * Shows a warning if a groupingId is given in resource configuration and
     * that resource is listed in the group with that groupingId.
     */
    addConfiguredGroups() {
        var _a;
        for (const group of (_a = this.config.groups) !== null && _a !== void 0 ? _a : []) {
            this.addGroup(group.id, group.name, group.description);
            for (const resourceKey of group.resources) {
                const existingResource = this.ig.definition.resource.find(resource => { var _a; return ((_a = resource.reference) === null || _a === void 0 ? void 0 : _a.reference) === resourceKey; });
                if (!existingResource) {
                    utils_1.logger.error(`Group ${group.id} configured with nonexistent resource ${resourceKey}`);
                }
                else {
                    if (existingResource.groupingId) {
                        if (existingResource.groupingId === group.id) {
                            utils_1.logger.warn(`Resource ${resourceKey} is listed as a member of group ${group.id}, and does not need a groupingId.`);
                        }
                        else {
                            utils_1.logger.error(`Resource ${resourceKey} configured with groupingId ${existingResource.groupingId}, but listed as member of group ${group.id}.`);
                        }
                    }
                    existingResource.groupingId = group.id;
                }
            }
        }
    }
    getMetaExtensionDescription(resource) {
        var _a, _b, _c;
        const description = (_c = (_b = (_a = resource.meta) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.find(e => e.url === 'http://hl7.org/fhir/StructureDefinition/instance-description')) === null || _c === void 0 ? void 0 : _c.valueMarkdown;
        if (!CONFORMANCE_AND_TERMINOLOGY_RESOURCES.has(resource.resourceType)) {
            return description;
        }
    }
    getMetaExtensionName(resource) {
        var _a, _b, _c;
        const name = (_c = (_b = (_a = resource.meta) === null || _a === void 0 ? void 0 : _a.extension) === null || _b === void 0 ? void 0 : _b.find(e => e.url === 'http://hl7.org/fhir/StructureDefinition/instance-name')) === null || _c === void 0 ? void 0 : _c.valueString;
        if (!CONFORMANCE_AND_TERMINOLOGY_RESOURCES.has(resource.resourceType)) {
            return name;
        }
    }
    /**
     * Writes the in-memory ImplementationGuide JSON to the IG output folder.
     *
     * @param igPath {string} - the path where the IG is exported to
     */
    addImplementationGuide(igPath) {
        const igJSONFolder = path_1.default.join('fsh-generated', 'resources');
        const igJsonPath = path_1.default.join(igPath, igJSONFolder, `ImplementationGuide-${this.ig.id}.json`);
        fs_extra_1.outputJSONSync(igJsonPath, this.ig, { spaces: 2 });
        utils_1.logger.info(`Generated ImplementationGuide-${this.ig.id}.json`);
    }
    /**
     * Logs an error if the no longer supported "template" property is used in sushi-config.yaml.
     */
    checkIgIni() {
        const inputIniPath = path_1.default.join(this.inputPath, 'ig.ini');
        if (this.config.template != null) {
            if (fs_extra_1.existsSync(inputIniPath)) {
                const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), 'ig.ini');
                const message = `Found both a "template" property in ${this.configName} and an ig.ini file at ${filePathString}. ` +
                    `The "template" property in ${this.configName} is no longer supported and will be ignored. The existing ` +
                    `${filePathString} file will be used instead. To resolve this error, remove the "template" property in ` +
                    `${this.configName} and manage the ig.ini file directly.`;
                utils_1.logger.error(message, { file: inputIniPath });
            }
            else {
                const message = `The "template" property in ${this.configName} is no longer supported. Please remove the "template" ` +
                    `property in ${this.configName} and manage the ig.ini file directly.` +
                    ` To resolve this error, create an ig.ini file in your project folder with the following contents:\n\n${this.generateIgIniString()}`;
                utils_1.logger.error(message);
            }
        }
        else if (fs_extra_1.existsSync(inputIniPath)) {
            this.processIgIni(inputIniPath);
        }
        else {
            // do nothing -- no template in config, no ig.ini provided
        }
    }
    /**
     * Generates the contents of an ig.ini file using the information in the configuration.
     *
     * @returns {string} contents of ig.ini file
     */
    generateIgIniString() {
        // Create an ig.ini object from the configuration
        const iniObj = {};
        const igFolder = 'fsh-generated/resources';
        iniObj.ig = `${igFolder}/ImplementationGuide-${this.config.id}.json`;
        iniObj.template = this.config.template;
        let outputIniContents = ini_1.default.encode(iniObj, { section: 'IG', whitespace: true });
        // The encoder escapes '#' but FHIR doesn't like that, so if `#` is escaped in the template, then unescape it.
        outputIniContents = outputIniContents.replace(/^template\s*=\s*.*?(\\#.+)?$/m, ($0, $1) => $1 ? $0.replace($1, $1.slice(1)) : $0);
        return outputIniContents;
    }
    /**
     * Process an existing ig.ini.
     * When one of the required properties is missing, an error is logged but the file is not changed.
     *
     * @param inputIniPath {string} - the path to the input ig.ini file
     */
    processIgIni(inputIniPath) {
        let inputIniContents = fs_extra_1.readFileSync(inputIniPath, 'utf8');
        // FHIR allows templates to have versions identified using #.  E.g.,
        //   template = hl7.fhir.template#0.1.0
        // The ini library, however, treats # as a comment unless it is escaped.  So if it exists, we need to escape it.
        inputIniContents = inputIniContents.replace(/^\s*template\s*=\s*[^#]*(#.+)?$/m, ($0, $1) => $1 ? $0.replace($1, `\\${$1}`) : $0);
        const inputIni = ini_1.default.parse(inputIniContents);
        if (Object.keys(inputIni).length > 1 || inputIni.IG == null) {
            utils_1.logger.error('ig.ini file must contain an [IG] section with no other sections', {
                file: inputIniPath
            });
        }
        const filePathString = path_1.default.join(path_1.default.basename(this.inputPath), 'ig.ini');
        if (inputIni.IG) {
            if (inputIni.IG.ig == null) {
                const igValue = `fsh-generated/resources/ImplementationGuide-${this.config.id}.json`;
                inputIni.IG.ig = igValue;
                utils_1.logger.error('The ig.ini file must have an "ig" property pointing to the IG file. Please add the following line ' +
                    `to ${filePathString}:\n'` +
                    `ig = ${igValue}`, {
                    file: inputIniPath
                });
            }
            if (inputIni.IG.template == null) {
                const templateValue = 'fhir.base.template';
                inputIni.IG.template = templateValue;
                utils_1.logger.error(`The ig.ini file must have a "template" property. Please update ${filePathString} to include ` +
                    'your desired template value. Consider adding the following line:\n' +
                    `template = ${templateValue}`, {
                    file: inputIniPath
                });
            }
            const deprecatedProps = [
                'copyrightyear',
                'license',
                'version',
                'ballotstatus',
                'fhirspec',
                'excludexml',
                'excludejson',
                'excludettl',
                'excludeMaps'
            ].filter(p => inputIni.IG.hasOwnProperty(p));
            if (deprecatedProps.length > 0) {
                const propList = deprecatedProps.join(', ');
                utils_1.logger.warn(`Your ${filePathString} file contains the following unsupported properties: ${propList}. ` +
                    'These are no longer supported in ig.ini and should be removed.  See the following link for details: ' +
                    'https://github.com/HL7/ig-template-base/releases/tag/0.0.2', {
                    file: inputIniPath
                });
            }
        }
    }
    /**
     * Logs an error if the no longer supported "history" property is used in sushi-config.yaml
     */
    checkPackageList() {
        if (this.config.history) {
            utils_1.logger.error('Detected "history" property in configuration. The use of "history" is no longer supported. Please remove the property and provide a package-list.json directly. ' +
                'The package-list.json corresponding to the "history" property in the configuration is:\n\n' +
                JSON.stringify(this.config.history, null, 2) +
                '\n');
        }
    }
}
exports.IGExporter = IGExporter;
/**
 * Creates a block of comments indicating that a file is generated and should not be directly edited,
 * allowing for the block comment delimiters to be passed in as well as any extra text to include.
 *
 * @param blockPrefix {string} - the comment prefix to use at the start of the block (e.g., <!-- {% comment %})
 * @param blockPostfix {string} - the comment postfix to use at the end of the block (e.g., {% endcomment %} -->)
 * @param extra {List<string>} - an array of strings, each of which is a line to include in the comment after the
 *   standard warning text
 * @param blankLineAfter {boolean} - whether or not to put a blank line after the block of comments
 * @returns {string} representing the formatted comments
 */
function warningBlock(blockPrefix = '', blockPostfix = '', extra = [], blankLineAfter = true) {
    const a = [blockPrefix, ...warningTextArray('', extra), blockPostfix, ''];
    if (blankLineAfter) {
        a.push('');
    }
    return a.join(os_1.EOL);
}
/**
 * Creates a set of comments as an array of strings, each representing a line in the comments.
 * These comments indicate that a file is generated and should not be directly edited, and this function
 * allows for the comment delimiters to be passed in as well as any extra text to include.
 *
 * @param prefix {string} - the comment prefix to use at the start of each line (e.g., <!--)
 * @param extra {List<string>} - an array of strings, each of which is a line to include in the comment after the
 *   standard warning text
 */
function warningTextArray(prefix, extra = []) {
    const msgLen = Math.max(85, ...extra.map(e => e.length));
    const a = [];
    const msg = (text = '', center = false) => {
        const fn = center ? lodash_1.pad : lodash_1.padEnd;
        a.push(`${prefix}* ${fn(text, msgLen)} *`);
    };
    a.push(`${prefix}${lodash_1.repeat('*', msgLen + 4)}`);
    msg('WARNING: DO NOT EDIT THIS FILE', true);
    msg();
    msg('This file is generated by SUSHI. Any edits you make to this file will be overwritten.');
    if (extra && extra.length > 0) {
        msg();
        extra.forEach(m => msg(m));
    }
    a.push(`${prefix}${lodash_1.repeat('*', msgLen + 4)}`);
    return a;
}
//# sourceMappingURL=IGExporter.js.map