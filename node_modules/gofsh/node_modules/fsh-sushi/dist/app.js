#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const commander_1 = __importDefault(require("commander"));
const chalk_1 = __importDefault(require("chalk"));
const process_1 = __importDefault(require("process"));
const lodash_1 = require("lodash");
const export_1 = require("./export");
const ig_1 = require("./ig");
const fhirdefs_1 = require("./fhirdefs");
const fhirdefs_2 = require("./fhirdefs");
const utils_1 = require("./utils");
const FSH_VERSION = '1.2.0';
app().catch(e => {
    utils_1.logger.error(`SUSHI encountered the following unexpected error: ${e.message}`);
    process_1.default.exit(1);
});
function app() {
    return __awaiter(this, void 0, void 0, function* () {
        let input;
        commander_1.default
            .name('sushi')
            .usage('[path-to-fsh-project] [options]')
            .option('-o, --out <out>', 'the path to the output folder')
            .option('-d, --debug', 'output extra debugging information')
            .option('-p, --preprocessed', 'output FSH produced by preprocessing steps')
            .option('-s, --snapshot', 'generate snapshot in Structure Definition output', false)
            .option('-i, --init', 'initialize a SUSHI project')
            .version(getVersion(), '-v, --version', 'print SUSHI version')
            .on('--help', () => {
            console.log('');
            console.log('Additional information:');
            console.log('  [path-to-fsh-project]');
            console.log('    Default: "."');
            console.log('  -o, --out <out>');
            console.log('    Default: "fsh-generated"');
        })
            .arguments('[path-to-fsh-defs]')
            .action(function (pathToFshDefs) {
            input = pathToFshDefs;
        })
            .parse(process_1.default.argv);
        if (commander_1.default.init) {
            yield utils_1.init();
            process_1.default.exit(0);
        }
        if (commander_1.default.debug)
            utils_1.logger.level = 'debug';
        input = utils_1.ensureInputDir(input);
        const rootIgnoreWarningsPath = path_1.default.join(input, 'sushi-ignoreWarnings.txt');
        const nestedIgnoreWarningsPath = path_1.default.join(input, 'input', 'sushi-ignoreWarnings.txt');
        if (fs_extra_1.default.existsSync(rootIgnoreWarningsPath)) {
            utils_1.setIgnoredWarnings(fs_extra_1.default.readFileSync(rootIgnoreWarningsPath, 'utf-8'));
            if (fs_extra_1.default.existsSync(nestedIgnoreWarningsPath)) {
                utils_1.logger.warn('Found sushi-ignoreWarnings.txt files in the following locations:\n\n' +
                    ` - ${rootIgnoreWarningsPath}\n` +
                    ` - ${nestedIgnoreWarningsPath}\n\n` +
                    `Only the file at ${rootIgnoreWarningsPath} will be processed. ` +
                    'Remove one of these files to avoid this warning.');
            }
        }
        else if (fs_extra_1.default.existsSync(nestedIgnoreWarningsPath)) {
            utils_1.setIgnoredWarnings(fs_extra_1.default.readFileSync(nestedIgnoreWarningsPath, 'utf-8'));
        }
        utils_1.logger.info(`Running ${getVersion()}`);
        utils_1.logger.info('Arguments:');
        if (commander_1.default.debug) {
            utils_1.logger.info('  --debug');
        }
        if (commander_1.default.preprocessed) {
            utils_1.logger.info('  --preprocessed');
        }
        if (commander_1.default.snapshot) {
            utils_1.logger.info('  --snapshot');
        }
        if (commander_1.default.out) {
            utils_1.logger.info(`  --out ${path_1.default.resolve(commander_1.default.out)}`);
        }
        utils_1.logger.info(`  ${path_1.default.resolve(input)}`);
        const originalInput = input;
        input = utils_1.findInputDir(input);
        // If an input/fsh subdirectory is used, we are in an IG Publisher context
        const fshFolder = path_1.default.basename(input) === 'fsh';
        const inputFshFolder = fshFolder && path_1.default.basename(path_1.default.dirname(input)) === 'input';
        if (!inputFshFolder) {
            // Since current supported tank configuration requires input/fsh folder,
            // both legacy IG publisher mode and legacy flat tank cases occur when
            // there is no input/fsh/ folder.
            // If we detect this case, things are about to go very wrong, so exit immediately.
            utils_1.logger.error('Migration to current SUSHI project structure is required. See above error message for details. Exiting.');
            process_1.default.exit(1);
        }
        const outDir = utils_1.ensureOutputDir(input, commander_1.default.out);
        let tank;
        let config;
        try {
            let rawFSH;
            if (!fs_extra_1.default.existsSync(input)) {
                // If we have a path that ends with input/fsh but that folder does not exist,
                // we are in a sushi-config.yaml-only case (current tank configuration with no FSH files)
                // so we can safely say there are no FSH files and therefore rawFSH is empty.
                rawFSH = [];
            }
            else {
                rawFSH = utils_1.getRawFSHes(input);
            }
            if (rawFSH.length === 0 && !fs_extra_1.default.existsSync(path_1.default.join(originalInput, 'sushi-config.yaml'))) {
                utils_1.logger.info('No FSH files or sushi-config.yaml present.');
                process_1.default.exit(0);
            }
            config = utils_1.readConfig(originalInput);
            tank = utils_1.fillTank(rawFSH, config);
        }
        catch (_a) {
            commander_1.default.outputHelp();
            process_1.default.exit(1);
        }
        // Load dependencies
        const defs = new fhirdefs_2.FHIRDefinitions();
        yield utils_1.loadExternalDependencies(defs, config);
        // Load custom resources. In current tank configuration (input/fsh), resources will be in input/
        fhirdefs_1.loadCustomResources(path_1.default.join(input, '..'), defs);
        // Check for StructureDefinition
        const structDef = defs.fishForFHIR('StructureDefinition', utils_1.Type.Resource);
        if (structDef == null || !utils_1.isSupportedFHIRVersion(structDef.version)) {
            utils_1.logger.error('Valid StructureDefinition resource not found. The FHIR package in your local cache' +
                ' may be corrupt. Local FHIR cache can be found at <home-directory>/.fhir/packages.' +
                ' For more information, see https://wiki.hl7.org/FHIR_Package_Cache#Location.');
            process_1.default.exit(1);
        }
        utils_1.logger.info('Converting FSH to FHIR resources...');
        const outPackage = export_1.exportFHIR(tank, defs);
        utils_1.writeFHIRResources(outDir, outPackage, defs, commander_1.default.snapshot);
        if (commander_1.default.preprocessed) {
            utils_1.logger.info('Writing preprocessed FSH...');
            utils_1.writePreprocessedFSH(outDir, input, tank);
        }
        // If FSHOnly is true in the config, do not generate IG content, otherwise, generate IG content
        if (config.FSHOnly) {
            utils_1.logger.info('Exporting FSH definitions only. No IG related content will be exported.');
        }
        else {
            const igFilesPath = path_1.default.resolve(input, '..', '..');
            utils_1.logger.info('Assembling Implementation Guide sources...');
            const igExporter = new ig_1.IGExporter(outPackage, defs, igFilesPath);
            igExporter.export(outDir);
            utils_1.logger.info('Assembled Implementation Guide sources; ready for IG Publisher.');
            if (!fs_extra_1.default
                .readdirSync(outDir)
                .some(file => file.startsWith('_genonce') || file.startsWith('_updatePublisher'))) {
                utils_1.logger.info('The sample-ig located at https://github.com/FHIR/sample-ig contains scripts useful for downloading and running the IG Publisher.');
            }
        }
        console.log();
        printResults(outPackage);
        process_1.default.exit(utils_1.stats.numError);
    });
}
function getVersion() {
    var _a;
    const packageJSONPath = path_1.default.join(__dirname, '..', 'package.json');
    if (fs_extra_1.default.existsSync(packageJSONPath)) {
        const sushiVersion = (_a = fs_extra_1.default.readJSONSync(packageJSONPath)) === null || _a === void 0 ? void 0 : _a.version;
        return `SUSHI v${sushiVersion} (implements FHIR Shorthand specification v${FSH_VERSION})`;
    }
    return 'unknown';
}
function printResults(pkg) {
    // NOTE: These variables are creatively names to align well in the strings below while keeping prettier happy
    const profileNum = lodash_1.pad(pkg.profiles.length.toString(), 13);
    const extentNum = lodash_1.pad(pkg.extensions.length.toString(), 12);
    const logiclNum = lodash_1.pad(pkg.logicals.length.toString(), 12);
    const resourcNum = lodash_1.pad(pkg.resources.length.toString(), 13);
    const valueSetsNumber = lodash_1.pad(pkg.valueSets.length.toString(), 18);
    const codeSystemsNum = lodash_1.pad(pkg.codeSystems.length.toString(), 17);
    const instancesNumber = lodash_1.pad(pkg.instances.length.toString(), 18);
    const errorNumMsg = lodash_1.pad(`${utils_1.stats.numError} Error${utils_1.stats.numError !== 1 ? 's' : ''}`, 13);
    const wrNumMsg = lodash_1.padStart(`${utils_1.stats.numWarn} Warning${utils_1.stats.numWarn !== 1 ? 's' : ''}`, 12);
    const aWittyMessageInvolvingABadFishPun = lodash_1.padEnd(utils_1.getRandomPun(utils_1.stats.numError, utils_1.stats.numWarn), 36);
    const clr = utils_1.stats.numError > 0 ? chalk_1.default.red : utils_1.stats.numWarn > 0 ? chalk_1.default.rgb(179, 98, 0) : chalk_1.default.green;
    // NOTE: Doing some funky things w/ strings on some lines to keep overall alignment in the code
    const results = [
        clr('╔' + '════════════════════════ SUSHI RESULTS ══════════════════════════' + '' + '╗'),
        clr('║') + ' ╭───────────────┬──────────────┬──────────────┬───────────────╮ ' + clr('║'),
        clr('║') + ' │    Profiles   │  Extensions  │   Logicals   │   Resources   │ ' + clr('║'),
        clr('║') + ' ├───────────────┼──────────────┼──────────────┼───────────────┤ ' + clr('║'),
        clr('║') + ` │ ${profileNum} │ ${extentNum} │ ${logiclNum} │ ${resourcNum} │ ` + clr('║'),
        clr('║') + ' ╰───────────────┴──────────────┴──────────────┴───────────────╯ ' + clr('║'),
        clr('║') + ' ╭────────────────────┬───────────────────┬────────────────────╮ ' + clr('║'),
        clr('║') + ' │      ValueSets     │    CodeSystems    │     Instances      │ ' + clr('║'),
        clr('║') + ' ├────────────────────┼───────────────────┼────────────────────┤ ' + clr('║'),
        clr('║') + ` │ ${valueSetsNumber} │ ${codeSystemsNum} │ ${instancesNumber} │ ` + clr('║'),
        clr('║') + ' ╰────────────────────┴───────────────────┴────────────────────╯ ' + clr('║'),
        clr('║' + '                                                                 ' + '' + '║'),
        clr('╠' + '═════════════════════════════════════════════════════════════════' + '' + '╣'),
        clr('║') + ` ${aWittyMessageInvolvingABadFishPun} ${errorNumMsg} ${wrNumMsg} ` + clr('║'),
        clr('╚' + '═════════════════════════════════════════════════════════════════' + '' + '╝')
    ];
    const convertChars = !supportsFancyCharacters();
    results.forEach(r => {
        if (convertChars) {
            r = r
                .replace(/[╔╝╚╗╠╣═]/g, '=')
                .replace(/[╭╯╰╮]/g, ' ')
                .replace(/[─┬┼┴]/g, '-')
                .replace(/[║│├┤]/g, '|');
        }
        console.log(r);
    });
}
function supportsFancyCharacters() {
    // There is no sure-fire way, but we know that most problems are when running in the IG Publisher,
    // so try to detect that situation (which is still actually pretty tricky and not guaranteed).
    // 1. Many JVM will insert an environment variable indicating the main Java class being run.
    //      E.g., JAVA_MAIN_CLASS_25538=org.hl7.fhir.igtools.publisher.Publisher
    //    We won't check the actual class; we'll just assume that if it's run in Java, best not take chances.
    if (Object.keys(process_1.default.env).some(k => /^JAVA_MAIN_CLASS/.test(k))) {
        return false;
    }
    // 2. It appears that in a Java-launched process, certain aspects of stdout aren't available, so
    //    use that to test if it's likely the fancy chars will be supported.
    if (process_1.default.stdout.hasColors === undefined) {
        return false;
    }
    // Otherwise, I guess (?) we're OK.  Worst case scenario: user gets rubbish characters in the summary
    return true;
}
//# sourceMappingURL=app.js.map