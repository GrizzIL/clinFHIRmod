"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilesRecursive = exports.init = exports.writePreprocessedFSH = exports.writeFHIRResources = exports.checkNullValuesOnArray = exports.fillTank = exports.getRawFSHes = exports.loadExternalDependencies = exports.readConfig = exports.ensureOutputDir = exports.findInputDir = exports.hasFshFiles = exports.ensureInputDir = exports.isSupportedFHIRVersion = void 0;
const axios_1 = __importDefault(require("axios"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const readline_sync_1 = __importDefault(require("readline-sync"));
const yaml_1 = __importDefault(require("yaml"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const FSHLogger_1 = require("./FSHLogger");
const fhirdefs_1 = require("../fhirdefs");
const import_1 = require("../import");
const EXT_PKG_TO_FHIR_PKG_MAP = {
    'hl7.fhir.extensions.r2': 'hl7.fhir.r2.core#1.0.2',
    'hl7.fhir.extensions.r3': 'hl7.fhir.r3.core#3.0.2',
    'hl7.fhir.extensions.r4': 'hl7.fhir.r4.core#4.0.1',
    'hl7.fhir.extensions.r5': 'hl7.fhir.r5.core#current'
};
function isSupportedFHIRVersion(version) {
    // For now, allow current or any 4.x version of FHIR except 4.0.0. This is a quick check; not a guarantee.  If a user passes
    // in an invalid version that passes this test (e.g., 4.99.0), it is still expected to fail when we load dependencies.
    return /current|4\.0\.1|4\.[1-9]\d*.\d+/.test(version);
}
exports.isSupportedFHIRVersion = isSupportedFHIRVersion;
function ensureInputDir(input) {
    // If no input folder is specified, set default to current directory
    if (!input) {
        input = '.';
        FSHLogger_1.logger.info('path-to-fsh-defs defaulted to current working directory');
    }
    return input;
}
exports.ensureInputDir = ensureInputDir;
function hasFshFiles(path) {
    try {
        fs_extra_1.default.statSync(path);
        const files = getFilesRecursive(path).filter(file => file.endsWith('.fsh'));
        return files.length > 0;
    }
    catch (error) {
        return false;
    }
}
exports.hasFshFiles = hasFshFiles;
function findInputDir(input) {
    const originalInput = input;
    const inputFshSubdirectoryPath = path_1.default.join(originalInput, 'input', 'fsh');
    const fshSubdirectoryPath = path_1.default.join(originalInput, 'fsh');
    const rootIgDataPath = path_1.default.join(originalInput, 'ig-data');
    const currentTankWithNoFsh = !fs_extra_1.default.existsSync(inputFshSubdirectoryPath) &&
        !fs_extra_1.default.existsSync(fshSubdirectoryPath) &&
        !fs_extra_1.default.existsSync(rootIgDataPath) &&
        !hasFshFiles(originalInput);
    // Use input/fsh/ subdirectory if not already specified and present
    // or when in the current tank configuration without FSH files
    if (fs_extra_1.default.existsSync(inputFshSubdirectoryPath) || currentTankWithNoFsh) {
        input = path_1.default.join(originalInput, 'input', 'fsh');
    }
    // TODO: Error about unsupported features. Remove when message no longer needed.
    // Use fsh/ subdirectory if not already specified and present
    if (!fs_extra_1.default.existsSync(inputFshSubdirectoryPath) && !currentTankWithNoFsh) {
        let msg = '\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n';
        if (fs_extra_1.default.existsSync(fshSubdirectoryPath)) {
            msg +=
                '\nSUSHI detected a "fsh" directory that will be used in the input path.\n' +
                    'Use of this folder is NO LONGER SUPPORTED.\n' +
                    'To migrate to the new folder structure, make the following changes:\n' +
                    `  - move fsh${path_1.default.sep}config.yaml to .${path_1.default.sep}sushi-config.yaml\n` +
                    `  - move fsh${path_1.default.sep}*.fsh files to .${path_1.default.sep}input${path_1.default.sep}fsh${path_1.default.sep}*.fsh\n`;
            if (fs_extra_1.default.existsSync(path_1.default.join(input, 'fsh', 'ig-data'))) {
                msg += `  - move fsh${path_1.default.sep}ig-data${path_1.default.sep}* files and folders to .${path_1.default.sep}*\n`;
            }
        }
        else {
            msg +=
                '\nSUSHI has adopted a new folder structure for FSH tanks (a.k.a. SUSHI projects).\n' +
                    'Support for other folder structures is NO LONGER SUPPORTED.\n' +
                    'To migrate to the new folder structure, make the following changes:\n' +
                    `  - rename .${path_1.default.sep}config.yaml to .${path_1.default.sep}sushi-config.yaml\n` +
                    `  - move .${path_1.default.sep}*.fsh files to .${path_1.default.sep}input${path_1.default.sep}fsh${path_1.default.sep}*.fsh\n`;
            if (fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data'))) {
                msg += `  - move .${path_1.default.sep}ig-data${path_1.default.sep}* files and folders to .${path_1.default.sep}*\n`;
            }
        }
        if (!fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data', 'ig.ini'))) {
            msg += `  - if you used the "template" property in your config, remove it and manage .${path_1.default.sep}ig.ini directly\n`;
        }
        if (!fs_extra_1.default.existsSync(path_1.default.join(input, 'ig-data', 'package-list.json'))) {
            msg += `  - if you used the "history" property in your config, remove it and manage .${path_1.default.sep}package-list.json directly\n`;
        }
        msg +=
            '  - ensure your .gitignore file is not configured to ignore the sources in their new locations\n' +
                '  - add /fsh-generated to your .gitignore file to prevent SUSHI output from being checked into source control\n\n' +
                `NOTE: After you make these changes, the default output folder for SUSHI will change to .${path_1.default.sep}fsh-generated.\n\n` +
                'For detailed migration instructions, see: https://fshschool.org/docs/sushi/migration/\n\n';
        FSHLogger_1.logger.error(msg);
    }
    return input;
}
exports.findInputDir = findInputDir;
function ensureOutputDir(input, output) {
    let outDir = output;
    if (!output) {
        // Default output is the parent folder of the input/fsh folder
        outDir = path_1.default.join(input, '..', '..');
        FSHLogger_1.logger.info(`No output path specified. Output to ${outDir}`);
    }
    fs_extra_1.default.ensureDirSync(outDir);
    // If the outDir contains a fsh-generated folder, we ensure that folder is empty
    const fshGeneratedFolder = path_1.default.join(outDir, 'fsh-generated');
    if (fs_extra_1.default.existsSync(fshGeneratedFolder)) {
        try {
            fs_extra_1.default.emptyDirSync(fshGeneratedFolder);
        }
        catch (e) {
            FSHLogger_1.logger.error(`Unable to empty existing fsh-generated folder because of the following error: ${e.message}`);
        }
    }
    return outDir;
}
exports.ensureOutputDir = ensureOutputDir;
function readConfig(input) {
    const configPath = import_1.ensureConfiguration(input);
    let config;
    if (configPath == null || !fs_extra_1.default.existsSync(configPath)) {
        config = import_1.loadConfigurationFromIgResource(input);
    }
    else {
        const configYaml = fs_extra_1.default.readFileSync(configPath, 'utf8');
        config = import_1.importConfiguration(configYaml, configPath);
    }
    if (!config) {
        FSHLogger_1.logger.error(`No sushi-config.yaml in ${input} folder, and no configuration could` +
            ' be extracted from an ImplementationGuide resource.');
        throw Error;
    }
    if (!config.fhirVersion.some(v => isSupportedFHIRVersion(v))) {
        FSHLogger_1.logger.error(`The ${path_1.default.basename(config.filePath)} must specify a supported version of FHIR. Be sure to` +
            ` add "fhirVersion: 4.0.1" (or 4.x.y, as appropriate) to the ${path_1.default.basename(config.filePath)} file.`);
        throw Error;
    }
    return config;
}
exports.readConfig = readConfig;
function loadExternalDependencies(defs, config) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // Add FHIR to the dependencies so it is loaded
        const dependencies = ((_a = config.dependencies) !== null && _a !== void 0 ? _a : []).slice(); // slice so we don't modify actual config;
        const fhirVersion = config.fhirVersion.find(v => isSupportedFHIRVersion(v));
        let fhirPackageId;
        let prerelease = false;
        if (fhirVersion.startsWith('4.0.')) {
            fhirPackageId = 'hl7.fhir.r4.core';
        }
        else if (fhirVersion.startsWith('4.1.')) {
            fhirPackageId = 'hl7.fhir.r4b.core';
            prerelease = true;
        }
        else if (fhirVersion.startsWith('4.3.')) {
            fhirPackageId = 'hl7.fhir.r4b.core';
        }
        else {
            fhirPackageId = 'hl7.fhir.r5.core';
            prerelease = true;
        }
        if (prerelease) {
            FSHLogger_1.logger.warn('SUSHI support for pre-release versions of FHIR is experimental. Use at your own risk!');
        }
        dependencies.push({ packageId: fhirPackageId, version: fhirVersion });
        // Load dependencies
        const promises = dependencies.map(dep => {
            var _a;
            if (dep.version == null) {
                FSHLogger_1.logger.error(`Failed to load ${dep.packageId}: No version specified. To specify the version in your ` +
                    `${path_1.default.basename(config.filePath)}, either use the simple dependency format:\n\n` +
                    'dependencies:\n' +
                    `  ${dep.packageId}: current\n\n` +
                    'or use the detailed dependency format to specify other properties as well:\n\n' +
                    'dependencies:\n' +
                    `  ${dep.packageId}:\n` +
                    `    uri: ${(_a = dep.uri) !== null && _a !== void 0 ? _a : 'http://my-fhir-ig.org/ImplementationGuide/123'}\n` +
                    '    version: current');
                return Promise.resolve();
            }
            else if (EXT_PKG_TO_FHIR_PKG_MAP[dep.packageId]) {
                // It is a special "virtual" FHIR extensions package indicating we need to load supplemental
                // FHIR versions to support "implied extensions".
                if (dep.version !== fhirVersion) {
                    FSHLogger_1.logger.warn(`Incorrect package version: ${dep.packageId}#${dep.version}. FHIR extensions packages ` +
                        "should use the same version as the implementation guide's fhirVersion. Version " +
                        `${fhirVersion} will be used instead. Update the dependency version in ` +
                        'sushi-config.yaml to eliminate this warning.');
                }
                FSHLogger_1.logger.info(`Loading supplemental version of FHIR to support extensions from ${dep.packageId}`);
                return fhirdefs_1.loadSupplementalFHIRPackage(EXT_PKG_TO_FHIR_PKG_MAP[dep.packageId], defs);
            }
            else {
                return fhirdefs_1.loadDependency(dep.packageId, dep.version, defs).catch(e => {
                    let message = `Failed to load ${dep.packageId}#${dep.version}: ${e.message}`;
                    if (/certificate/.test(e.message)) {
                        message +=
                            '\n\nSometimes this error occurs in corporate or educational environments that use proxies and/or SSL ' +
                                'inspection.\nTroubleshooting tips:\n' +
                                '  1. If a non-proxied network is available, consider connecting to that network instead.\n' +
                                '  2. Set NODE_EXTRA_CA_CERTS as described at https://bit.ly/3ghJqJZ (RECOMMENDED).\n' +
                                '  3. Disable certificate validation as described at https://bit.ly/3syjzm7 (NOT RECOMMENDED).\n';
                    }
                    FSHLogger_1.logger.error(message);
                });
            }
        });
        return Promise.all(promises).then(() => { });
    });
}
exports.loadExternalDependencies = loadExternalDependencies;
function getRawFSHes(input) {
    let files;
    try {
        fs_extra_1.default.statSync(input);
        files = getFilesRecursive(input);
    }
    catch (_a) {
        FSHLogger_1.logger.error('Invalid path to FSH definition folder.');
        throw Error;
    }
    const rawFSHes = files
        .filter(file => file.endsWith('.fsh'))
        .map(file => {
        const filePath = path_1.default.resolve(file);
        const fileContent = fs_extra_1.default.readFileSync(filePath, 'utf8');
        return new import_1.RawFSH(fileContent, filePath);
    });
    return rawFSHes;
}
exports.getRawFSHes = getRawFSHes;
function fillTank(rawFSHes, config) {
    FSHLogger_1.logger.info('Importing FSH text...');
    const docs = import_1.importText(rawFSHes);
    return new import_1.FSHTank(docs, config);
}
exports.fillTank = fillTank;
function checkNullValuesOnArray(resource, parentName = '', priorPath = '') {
    var _a;
    const resourceName = parentName ? parentName : (_a = resource.id) !== null && _a !== void 0 ? _a : resource.name;
    for (const propertyKey in resource) {
        const property = resource[propertyKey];
        const currentPath = !priorPath ? propertyKey : priorPath.concat(`.${propertyKey}`);
        // If a property's key begins with "_", we'll want to ignore null values on it's top level
        // but still check any nested objects for null values
        if (propertyKey.startsWith('_')) {
            if (lodash_1.isPlainObject(property)) {
                // If we encounter an object property, we'll want to check its properties as well
                checkNullValuesOnArray(property, resourceName, currentPath);
            }
            if (Array.isArray(property)) {
                property.forEach((element, index) => {
                    if (lodash_1.isPlainObject(element)) {
                        // If we encounter an object property, we'll want to check its properties as well
                        checkNullValuesOnArray(element, resourceName, `${currentPath}[${index}]`);
                    }
                });
            }
        }
        else {
            if (lodash_1.isPlainObject(property)) {
                // If we encounter an object property, we'll want to check its properties as well
                checkNullValuesOnArray(property, resourceName, currentPath);
            }
            if (Array.isArray(property)) {
                const nullIndexes = [];
                property.forEach((element, index) => {
                    if (element === null)
                        nullIndexes.push(index);
                    if (lodash_1.isPlainObject(element)) {
                        // If we encounter an object property, we'll want to check its properties as well
                        checkNullValuesOnArray(element, resourceName, `${currentPath}[${index}]`);
                    }
                });
                if (nullIndexes.length > 0) {
                    FSHLogger_1.logger.warn(`The array '${currentPath}' in ${resourceName} is missing values at the following indices: ${nullIndexes}`);
                }
            }
        }
    }
}
exports.checkNullValuesOnArray = checkNullValuesOnArray;
function writeFHIRResources(outDir, outPackage, defs, snapshot) {
    FSHLogger_1.logger.info('Exporting FHIR resources as JSON...');
    let count = 0;
    const predefinedResources = defs.allPredefinedResources();
    const writeResources = (resources) => {
        const exportDir = path_1.default.join(outDir, 'fsh-generated', 'resources');
        resources.forEach(resource => {
            var _a;
            if (!predefinedResources.find(predef => predef.url === resource.url &&
                predef.resourceType === resource.resourceType &&
                predef.id === resource.id)) {
                checkNullValuesOnArray(resource);
                fs_extra_1.default.outputJSONSync(path_1.default.join(exportDir, resource.getFileName()), resource.toJSON(snapshot), {
                    spaces: 2
                });
                count++;
            }
            else {
                FSHLogger_1.logger.error(`Ignoring FSH definition for ${(_a = resource.url) !== null && _a !== void 0 ? _a : `${resource.resourceType}/${resource.id}`} since it duplicates existing pre-defined resource. ` +
                    'To use the FSH definition, remove the conflicting file from "input". ' +
                    'If you do want the FSH definition to be ignored, please comment the definition out ' +
                    'to remove this error.');
            }
        });
    };
    writeResources(outPackage.profiles);
    writeResources(outPackage.extensions);
    writeResources(outPackage.logicals);
    // WARNING: While custom resources are written to disk, the IG Publisher does not
    //          accept newly defined resources. However, it is configured to automatically
    //          search the fsh-generated directory for StructureDefinitions rather than using
    //          the StructureDefinitions defined in the exported implementation guide. So, be
    //          aware that the IG Publisher will attempt to process custom resources.
    //          NOTE: To mitigate against this, the parameter 'autoload-resources = false' is
    //          injected automatically into the IG array pf parameters if the parameter was
    //          not already defined and only if the custom resources were generated by Sushi.
    writeResources(outPackage.resources);
    writeResources([...outPackage.valueSets, ...outPackage.codeSystems]);
    // Filter out inline instances
    writeResources(outPackage.instances.filter(i => i._instanceMeta.usage !== 'Inline'));
    FSHLogger_1.logger.info(`Exported ${count} FHIR resources as JSON.`);
}
exports.writeFHIRResources = writeFHIRResources;
function writePreprocessedFSH(outDir, inDir, tank) {
    const preprocessedPath = path_1.default.join(outDir, '_preprocessed');
    fs_extra_1.default.ensureDirSync(preprocessedPath);
    // Because this is the FSH that exists after processing, some entities from the original FSH are gone.
    // Specifically, RuleSets have already been applied.
    // Aliases have already been resolved for most cases, but since they may still
    // be used in a slice name, they are included.
    // TODO: Add Resources and Logicals once they are being imported and stored in docs
    tank.docs.forEach(doc => {
        let fileContent = '';
        // First, get all Aliases. They don't have source information.
        if (doc.aliases.size > 0) {
            doc.aliases.forEach((url, alias) => {
                fileContent += `Alias: ${alias} = ${url}${os_1.EOL}`;
            });
            fileContent += os_1.EOL;
        }
        // Then, get all other applicable entities. They will have source information.
        const entities = [
            ...doc.profiles.values(),
            ...doc.extensions.values(),
            ...doc.logicals.values(),
            ...doc.resources.values(),
            ...doc.instances.values(),
            ...doc.valueSets.values(),
            ...doc.codeSystems.values(),
            ...doc.invariants.values(),
            ...doc.mappings.values()
        ];
        // Sort entities by original line number, then write them out.
        lodash_1.sortBy(entities, 'sourceInfo.location.startLine').forEach(entity => {
            fileContent += `// Originally defined on lines ${entity.sourceInfo.location.startLine} - ${entity.sourceInfo.location.endLine}${os_1.EOL}`;
            fileContent += `${entity.toFSH()}${os_1.EOL}${os_1.EOL}`;
        });
        if (fileContent.length === 0) {
            fileContent = '// This file has no content after preprocessing.';
        }
        const outPath = path_1.default.relative(inDir, doc.file);
        fs_extra_1.default.ensureFileSync(path_1.default.join(preprocessedPath, outPath));
        fs_extra_1.default.writeFileSync(path_1.default.join(preprocessedPath, outPath), fileContent);
    });
    FSHLogger_1.logger.info(`Wrote preprocessed FSH to ${preprocessedPath}`);
}
exports.writePreprocessedFSH = writePreprocessedFSH;
/**
 * Initializes an empty sample FSH within a user specified subdirectory of the current working directory
 */
function init() {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('\n╭───────────────────────────────────────────────────────────╮\n' +
            '│ This interactive tool will use your answers to create a   │\n' +
            "│ working SUSHI project configured with your project's      │\n" +
            '│ basic information.                                        │\n' +
            '╰───────────────────────────────────────────────────────────╯\n');
        const configDoc = yaml_1.default.parseDocument(fs_extra_1.default.readFileSync(path_1.default.join(__dirname, 'init-project', 'sushi-config.yaml'), 'utf-8'));
        // Accept user input for certain fields
        ['name', 'id', 'canonical', 'status', 'version'].forEach(field => {
            const userValue = readline_sync_1.default.question(`${lodash_1.upperFirst(field)} (Default: ${configDoc.get(field)}): `);
            if (userValue) {
                if (field === 'status') {
                    const node = yaml_1.default.createNode(userValue);
                    node.comment = ' draft | active | retired | unknown';
                    configDoc.set(field, node);
                }
                else {
                    configDoc.set(field, userValue);
                }
            }
        });
        // And for nested publisher fields
        ['name', 'url'].forEach(field => {
            const userValue = readline_sync_1.default.question(`Publisher ${lodash_1.upperFirst(field)} (Default: ${configDoc.get('publisher').get(field)}): `);
            if (userValue) {
                configDoc.get('publisher').set(field, userValue);
            }
        });
        // Ensure copyrightYear is accurate
        configDoc.set('copyrightYear', `${new Date().getFullYear()}+`);
        const projectName = configDoc.get('name');
        // Write init directory out, including user made sushi-config.yaml, files in utils/init-project, and build scripts from ig/files
        const outputDir = path_1.default.resolve('.', projectName);
        const initProjectDir = path_1.default.join(__dirname, 'init-project');
        if (!readline_sync_1.default.keyInYN(`Initialize SUSHI project in ${outputDir}?`)) {
            console.log('\nAborting Initialization.\n');
            return;
        }
        // Add index.md content, updating to reflect the user given name
        const indexPageContent = fs_extra_1.default
            .readFileSync(path_1.default.join(initProjectDir, 'index.md'), 'utf-8')
            .replace('ExampleIG', projectName);
        fs_extra_1.default.ensureDirSync(path_1.default.join(outputDir, 'input', 'pagecontent'));
        fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'input', 'pagecontent', 'index.md'), indexPageContent);
        // Add ig.ini, updating to reflect the user given id
        const iniContent = fs_extra_1.default
            .readFileSync(path_1.default.join(initProjectDir, 'ig.ini'), 'utf-8')
            .replace('fhir.example', configDoc.get('id'));
        fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'ig.ini'), iniContent);
        // Add the config
        fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, 'sushi-config.yaml'), configDoc.toString());
        // Copy over remaining static files
        fs_extra_1.default.ensureDirSync(path_1.default.join(outputDir, 'input', 'fsh'));
        fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'patient.fsh'), path_1.default.join(outputDir, 'input', 'fsh', 'patient.fsh'));
        fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'init-gitignore.txt'), path_1.default.join(outputDir, '.gitignore'));
        fs_extra_1.default.copyFileSync(path_1.default.join(initProjectDir, 'ignoreWarnings.txt'), path_1.default.join(outputDir, 'input', 'ignoreWarnings.txt'));
        // Add the _updatePublisher, _genonce, and _gencontinuous scripts
        console.log('Downloading publisher scripts from https://github.com/HL7/ig-publisher-scripts');
        for (const script of [
            '_genonce.bat',
            '_genonce.sh',
            '_updatePublisher.bat',
            '_updatePublisher.sh'
        ]) {
            const url = `http://raw.githubusercontent.com/HL7/ig-publisher-scripts/main/${script}`;
            try {
                const res = yield axios_1.default.get(url);
                fs_extra_1.default.writeFileSync(path_1.default.join(outputDir, script), res.data);
                if (script.endsWith('.sh')) {
                    fs_extra_1.default.chmodSync(path_1.default.join(outputDir, script), 0o755);
                }
            }
            catch (e) {
                FSHLogger_1.logger.error(`Unable to download ${script} from ${url}: ${e.message}`);
            }
        }
        const maxLength = 32;
        const printName = projectName.length > maxLength ? projectName.slice(0, maxLength - 3) + '...' : projectName;
        console.log('\n╭───────────────────────────────────────────────────────────╮\n' +
            `│ Project initialized at: ./${lodash_1.padEnd(printName, maxLength)}│\n` +
            '├───────────────────────────────────────────────────────────┤\n' +
            '│ Now try this:                                             │\n' +
            '│                                                           │\n' +
            `│ > cd ${lodash_1.padEnd(printName, maxLength + 21)}│\n` +
            '│ > sushi .                                                 │\n' +
            '│                                                           │\n' +
            '│ For guidance on project structure and configuration see   │\n' +
            '│ the SUSHI documentation: https://fshschool.org/docs/sushi │\n' +
            '╰───────────────────────────────────────────────────────────╯\n');
    });
}
exports.init = init;
function getFilesRecursive(dir) {
    // always return absolute paths
    const absPath = path_1.default.resolve(dir);
    try {
        if (fs_extra_1.default.statSync(absPath).isDirectory()) {
            const descendants = fs_extra_1.default
                .readdirSync(absPath, 'utf8')
                .map(f => getFilesRecursive(path_1.default.join(absPath, f)));
            return [].concat(...descendants);
        }
        else {
            return [absPath];
        }
    }
    catch (_a) {
        return [];
    }
}
exports.getFilesRecursive = getFilesRecursive;
//# sourceMappingURL=Processing.js.map