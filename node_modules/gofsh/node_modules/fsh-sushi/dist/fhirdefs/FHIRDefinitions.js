"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FHIRDefinitions = void 0;
const utils_1 = require("../utils");
const impliedExtensions_1 = require("./impliedExtensions");
const lodash_1 = require("lodash");
const fhirtypes_1 = require("../fhirtypes");
class FHIRDefinitions {
    constructor(isSupplementalFHIRDefinitions = false) {
        this.isSupplementalFHIRDefinitions = isSupplementalFHIRDefinitions;
        this.packages = [];
        this.resources = new Map();
        this.logicals = new Map();
        this.profiles = new Map();
        this.extensions = new Map();
        this.types = new Map();
        this.valueSets = new Map();
        this.codeSystems = new Map();
        this.implementationGuides = new Map();
        this.predefinedResources = new Map();
        this.supplementalFHIRDefinitions = new Map();
        // FHIR R4 does not have a StructureDefinition that defines "Base" but FHIR R5 does.
        // We have defined a "placeholder" StructureDefinition for "Base" for R4.
        // Inject the R4 "Base" placeholder StructureDefinition
        this.add(fhirtypes_1.STRUCTURE_DEFINITION_R4_BASE);
    }
    // This getter is only used in tests to verify what supplemental packages are loaded
    get supplementalFHIRPackages() {
        return lodash_1.flatten(Array.from(this.supplementalFHIRDefinitions.values()).map(defs => defs.packages));
    }
    size() {
        return (this.resources.size +
            this.logicals.size +
            this.profiles.size +
            this.extensions.size +
            this.types.size +
            this.valueSets.size +
            this.codeSystems.size +
            this.implementationGuides.size);
    }
    // NOTE: These all return clones of the JSON to prevent the source values from being overwritten
    allResources() {
        return cloneJsonMapValues(this.resources);
    }
    allLogicals() {
        return cloneJsonMapValues(this.logicals);
    }
    allProfiles() {
        return cloneJsonMapValues(this.profiles);
    }
    allExtensions() {
        return cloneJsonMapValues(this.extensions);
    }
    allTypes() {
        return cloneJsonMapValues(this.types);
    }
    allValueSets() {
        return cloneJsonMapValues(this.valueSets);
    }
    allCodeSystems() {
        return cloneJsonMapValues(this.codeSystems);
    }
    allImplementationGuides() {
        return cloneJsonMapValues(this.implementationGuides);
    }
    allPredefinedResources() {
        return cloneJsonMapValues(this.predefinedResources);
    }
    add(definition) {
        // For supplemental FHIR versions, we only care about resources and types,
        // but for normal packages, we care about everything.
        if (definition.resourceType === 'StructureDefinition') {
            if (definition.type === 'Extension' &&
                definition.baseDefinition !== 'http://hl7.org/fhir/StructureDefinition/Element' &&
                !this.isSupplementalFHIRDefinitions) {
                addDefinitionToMap(definition, this.extensions);
            }
            else if (definition.kind === 'primitive-type' ||
                definition.kind === 'complex-type' ||
                definition.kind === 'datatype') {
                addDefinitionToMap(definition, this.types);
            }
            else if (definition.kind === 'resource') {
                if (definition.derivation === 'constraint') {
                    if (!this.isSupplementalFHIRDefinitions) {
                        addDefinitionToMap(definition, this.profiles);
                    }
                }
                else {
                    addDefinitionToMap(definition, this.resources);
                }
            }
            else if (definition.kind === 'logical') {
                if (definition.derivation === 'specialization') {
                    addDefinitionToMap(definition, this.logicals);
                }
                else if (!this.isSupplementalFHIRDefinitions) {
                    addDefinitionToMap(definition, this.profiles);
                }
            }
        }
        else if (definition.resourceType === 'ValueSet' && !this.isSupplementalFHIRDefinitions) {
            addDefinitionToMap(definition, this.valueSets);
        }
        else if (definition.resourceType === 'CodeSystem' && !this.isSupplementalFHIRDefinitions) {
            addDefinitionToMap(definition, this.codeSystems);
        }
        else if (definition.resourceType === 'ImplementationGuide' &&
            !this.isSupplementalFHIRDefinitions) {
            addDefinitionToMap(definition, this.implementationGuides);
        }
    }
    addPredefinedResource(file, definition) {
        this.predefinedResources.set(file, definition);
    }
    getPredefinedResource(file) {
        return this.predefinedResources.get(file);
    }
    resetPredefinedResources() {
        this.predefinedResources = new Map();
    }
    addSupplementalFHIRDefinitions(fhirPackage, definitions) {
        this.supplementalFHIRDefinitions.set(fhirPackage, definitions);
    }
    getSupplementalFHIRDefinitions(fhirPackage) {
        return this.supplementalFHIRDefinitions.get(fhirPackage);
    }
    fishForPredefinedResource(item, ...types) {
        const resource = this.fishForFHIR(item, ...types);
        if (resource &&
            this.allPredefinedResources().find(predefResource => predefResource.id === resource.id &&
                predefResource.resourceType === resource.resourceType &&
                predefResource.url === resource.url)) {
            return resource;
        }
    }
    fishForPredefinedResourceMetadata(item, ...types) {
        const resource = this.fishForPredefinedResource(item, ...types);
        if (resource) {
            return {
                id: resource.id,
                name: resource.name,
                sdType: resource.type,
                url: resource.url,
                parent: resource.baseDefinition,
                abstract: resource.abstract,
                resourceType: resource.resourceType
            };
        }
    }
    fishForFHIR(item, ...types) {
        // No types passed in means to search ALL supported types
        if (types.length === 0) {
            types = [
                utils_1.Type.Resource,
                utils_1.Type.Logical,
                utils_1.Type.Type,
                utils_1.Type.Profile,
                utils_1.Type.Extension,
                utils_1.Type.ValueSet,
                utils_1.Type.CodeSystem
            ];
        }
        for (const type of types) {
            let def;
            switch (type) {
                case utils_1.Type.Resource:
                    def = lodash_1.cloneDeep(this.resources.get(item));
                    break;
                case utils_1.Type.Logical:
                    def = lodash_1.cloneDeep(this.logicals.get(item));
                    break;
                case utils_1.Type.Type:
                    def = lodash_1.cloneDeep(this.types.get(item));
                    break;
                case utils_1.Type.Profile:
                    def = lodash_1.cloneDeep(this.profiles.get(item));
                    break;
                case utils_1.Type.Extension:
                    def = lodash_1.cloneDeep(this.extensions.get(item));
                    break;
                case utils_1.Type.ValueSet:
                    def = lodash_1.cloneDeep(this.valueSets.get(item));
                    break;
                case utils_1.Type.CodeSystem:
                    def = lodash_1.cloneDeep(this.codeSystems.get(item));
                    break;
                case utils_1.Type.Instance: // don't support resolving to FHIR instances
                default:
                    break;
            }
            if (def) {
                return def;
            }
        }
        // If it's an "implied extension", try to materialize it. See:http://hl7.org/fhir/versions.html#extensions
        if (impliedExtensions_1.IMPLIED_EXTENSION_REGEX.test(item) && types.some(t => t === utils_1.Type.Extension)) {
            return impliedExtensions_1.materializeImpliedExtension(item, this);
        }
    }
    fishForMetadata(item, ...types) {
        const result = this.fishForFHIR(item, ...types);
        if (result) {
            return {
                id: result.id,
                name: result.name,
                sdType: result.type,
                url: result.url,
                parent: result.baseDefinition,
                abstract: result.abstract,
                resourceType: result.resourceType
            };
        }
    }
}
exports.FHIRDefinitions = FHIRDefinitions;
function addDefinitionToMap(def, defMap) {
    if (def.id) {
        defMap.set(def.id, def);
    }
    if (def.url) {
        defMap.set(def.url, def);
    }
    if (def.name) {
        defMap.set(def.name, def);
    }
}
function cloneJsonMapValues(map) {
    return Array.from(map.values()).map(v => lodash_1.cloneDeep(v));
}
//# sourceMappingURL=FHIRDefinitions.js.map