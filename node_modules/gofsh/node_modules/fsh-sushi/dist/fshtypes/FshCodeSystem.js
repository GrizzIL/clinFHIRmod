"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FshCodeSystem = void 0;
const FshEntity_1 = require("./FshEntity");
const CodeSystemDuplicateCodeError_1 = require("../errors/CodeSystemDuplicateCodeError");
const CodeSystemIncorrectHierarchyError_1 = require("../errors/CodeSystemIncorrectHierarchyError");
const rules_1 = require("./rules");
const os_1 = require("os");
const common_1 = require("./common");
const isEqual_1 = __importDefault(require("lodash/isEqual"));
/**
 * For more information about a CodeSystem in FHIR,
 * @see {@link http://hl7.org/fhir/codesystem-definitions.html}
 */
class FshCodeSystem extends FshEntity_1.FshEntity {
    constructor(name) {
        super();
        this.name = name;
        this.id = name;
        this.rules = [];
    }
    get constructorName() {
        return 'FshCodeSystem';
    }
    addConcept(newConcept) {
        if (this.checkConcept(newConcept)) {
            this.rules.push(newConcept);
        }
    }
    checkConcept(newConcept) {
        const existingConcept = this.rules.find(rule => rule instanceof rules_1.ConceptRule && rule.code == newConcept.code);
        if (existingConcept) {
            // if the new ConceptRule has only a code and a hierarchy,
            // and the existing ConceptRule with that code has a matching hierarchy,
            // the user may simply be referencing the existing concept to establish context.
            if (newConcept.display == null &&
                newConcept.definition == null &&
                isEqual_1.default(existingConcept.hierarchy, newConcept.hierarchy)) {
                return false;
            }
            else {
                throw new CodeSystemDuplicateCodeError_1.CodeSystemDuplicateCodeError(this.id, newConcept.code);
            }
        }
        // check the hierarchy, if applicable
        // for each predecessor element in the new concept's hierarchy, we should be able to find a rule that
        // 1. defines a concept
        // 2. with the predecessor's code
        // 3. and a hierarchy equal to everything before it in the new concept's hierarchy
        newConcept.hierarchy.forEach((predecessor, i) => {
            if (!this.rules.some(rule => {
                return (rule instanceof rules_1.ConceptRule &&
                    rule.code === predecessor &&
                    isEqual_1.default(rule.hierarchy, newConcept.hierarchy.slice(0, i)));
            })) {
                throw new CodeSystemIncorrectHierarchyError_1.CodeSystemIncorrectHierarchyError(this.id, newConcept.code);
            }
        });
        return true;
    }
    metadataToFSH() {
        const resultLines = [];
        resultLines.push(`CodeSystem: ${this.name}`);
        resultLines.push(`Id: ${this.id}`);
        if (this.title) {
            resultLines.push(`Title: "${common_1.fshifyString(this.title)}"`);
        }
        if (this.description) {
            // Description can be a multiline string.
            // If it contains newline characters, treat it as a multiline string.
            if (this.description.indexOf('\n') > -1) {
                resultLines.push(`Description: """${this.description}"""`);
            }
            else {
                resultLines.push(`Description: "${common_1.fshifyString(this.description)}"`);
            }
        }
        return resultLines.join(os_1.EOL);
    }
    toFSH() {
        const metadataFSH = this.metadataToFSH();
        const rulesFSH = this.rules.map(r => r.toFSH()).join(os_1.EOL);
        return `${metadataFSH}${rulesFSH.length ? os_1.EOL + rulesFSH : ''}`;
    }
}
exports.FshCodeSystem = FshCodeSystem;
//# sourceMappingURL=FshCodeSystem.js.map