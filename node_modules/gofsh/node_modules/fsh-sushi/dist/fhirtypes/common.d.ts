import { StructureDefinition, PathPart, ElementDefinition, InstanceDefinition, ValueSet, CodeSystem } from '.';
import { AssignmentRule, CaretValueRule } from '../fshtypes/rules';
import { Instance, Logical, Profile, Extension, RuleSet, FshValueSet, FshCodeSystem, Mapping, Resource, FshEntity } from '../fshtypes';
import { FSHTank } from '../import';
import { Fishable } from '../utils/Fishable';
export declare function splitOnPathPeriods(path: string): string[];
/**
 * This function sets an instance property of an SD or ED if possible
 * @param {StructureDefinition | ElementDefinition} instance - The instance to assign a value on
 * @param {string} path - The path to assign a value at
 * @param {any} value - The value to assign
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 */
export declare function setPropertyOnDefinitionInstance(instance: StructureDefinition | ElementDefinition, path: string, value: any, fisher: Fishable): void;
export declare function setImpliedPropertiesOnInstance(instanceDef: StructureDefinition | ElementDefinition | InstanceDefinition, instanceOfStructureDefinition: StructureDefinition, paths: string[], fisher: Fishable): void;
export declare function setPropertyOnInstance(instance: StructureDefinition | ElementDefinition | InstanceDefinition | ValueSet | CodeSystem, pathParts: PathPart[], assignedValue: any, fisher: Fishable): void;
/**
 * Tests to see if the last bracket in a PathPart is a non-negative int, and if so returns it
 * @param {PathPart} pathPart - The part of the path to test
 * @returns {number} The index if it exists and is non-negative, otherwise undefined
 *
 */
export declare function getArrayIndex(pathPart: PathPart): number;
/**
 * Replaces references to instances by the correct path to that instance.
 * Replaces references to local code systems by the url for that code system.
 * @param {AssignmentRule} rule - The rule to replace references on
 * @param {FSHTank} tank - The tank holding the instances and code systems
 * @param {Fishable} fisher - A fishable implementation for finding definitions and metadata
 * @returns {AssignmentRule} a clone of the rule if replacing is done, otherwise the original rule
 */
export declare function replaceReferences<T extends AssignmentRule | CaretValueRule>(rule: T, tank: FSHTank, fisher: Fishable): T;
export declare function listUndefinedLocalCodes(codeSystem: FshCodeSystem | Instance, codes: string[], tank: FSHTank, sourceEntity: FshEntity): void;
/**
 * Returns the sliceName for a set of pathParts
 * @param {PathPart} pathPart - The part of the path to get a sliceName for
 * @returns {string} The slicenName for the path part
 */
export declare function getSliceName(pathPart: PathPart): string;
/**
 * Replaces fields in an object that match a certain condition
 * @param { {[key: string]: any} } object - The object to replace fields on
 * @param {(object: { [key: string]: any }, prop: string) => boolean} matchFn - The function to match with
 * @param {(object: { [key: string]: any }, prop: string) => void} replaceFn - The function to replace with
 * @param {(object: { [key: string]: any }, prop: string) => boolean} skipFn - A function that returns true if a property should not be traversed
 */
export declare function replaceField(object: {
    [key: string]: any;
}, matchFn: (object: {
    [key: string]: any;
}, prop: string) => boolean, replaceFn: (object: {
    [key: string]: any;
}, prop: string) => void, skipFn: (prop: string) => boolean): void;
/**
 * Cleans up temporary properties that were added to the resource definition during processing
 * @param {StructureDefinition | InstanceDefinition} resourceDef - The resource definition to clean
 * @param {string => boolean} skipFn - A function that returns true if a property should not be traversed
 */
export declare function cleanResource(resourceDef: StructureDefinition | InstanceDefinition, skipFn?: (prop: string) => boolean): void;
/**
 * Adds insert rules onto a Profile, Extension, or Instance
 * @param fshDefinition - The definition to apply rules on
 * @param tank - The FSHTank containing the fshDefinition
 */
export declare function applyInsertRules(fshDefinition: Profile | Extension | Logical | Resource | Instance | FshValueSet | FshCodeSystem | Mapping | RuleSet, tank: FSHTank, seenRuleSets?: string[]): void;
/**
 * Finds all FSH paths implied by the FSH path pointing at element. Paths are implied by array elements.
 * For example, if foo is 2..* and bar is 2..*, and bar has a assigned value of "hello", then the rule
 * "foo[0].baz = "hey" " implies the following:
 * foo[0].baz = "hey"
 * foo[0].bar[0] = "hello"
 * foo[1].bar[0] = "hello"
 * foo[0].bar[1] = "hello"
 * foo[1].bar[1] = "hello"
 * @param {ElementDefinition} element - The element that the path corresponds to
 * @param {path} string - The FSH path to the element
 * @returns {string[]} - All implied FSH paths by the path pointing to element
 */
export declare function getAllImpliedPaths(element: ElementDefinition, path: string): string[];
/**
 * Tests if resourceType is a valid FHIR resource that is a subtype of type. This is the case
 * if type is Resource, or if type is DomainResource and resourceType is one of the resources
 * that inherits from DomainResource, or if type is equal to resourceType.
 * @param {string} resourceType - The resourceType to test inheritance of
 * @param {string} type - The original type being inherited from
 * @param {Fishable} fisher - A fisher for finding FHIR definitions
 * @param {boolean} allowProfile - True if profiles of inherited resource should be allowed
 * @returns {boolean} true if resourceType is a valid sub-type of type, false otherwise
 */
export declare function isInheritedResource(resourceType: string, type: string, fisher: Fishable, allowProfile?: boolean): boolean;
/**
 * Determines the formal FHIR URL to use to refer to this entity (for example when fishing).
 * If a caret value rule has been applied to the entity's url, use the value specified in that
 * rule. Otherwise, use the default url based on the configured canonical url.
 *
 * @param fshDefinition - The FSH definition that the returned URL refers to
 * @param canonical - The canonical URL for the FSH project
 * @returns The URL to use to refer to the FHIR entity
 */
export declare function getUrlFromFshDefinition(fshDefinition: Profile | Extension | Logical | Resource | FshValueSet | FshCodeSystem | Instance, canonical: string): string;
/**
 * Determines the formal FHIR type to use to define to this entity for logical models and
 * resources. The type for profiles and extension should not be changed. If a caret value
 * rule has been applied to the entity's type, use the value specified in that rule.
 * Otherwise, use the appropriate default based on the fshDefinition.
 *
 * @param fshDefinition - The FSH definition (Logical or Resource) that the returned type refers to
 * @param parentSD - The parent StructureDefinition for the fshDefinition
 * @returns The type to specify in the StructureDefinition for this fshDefinition
 */
export declare function getTypeFromFshDefinitionOrParent(fshDefinition: Profile | Extension | Logical | Resource, parentSD: StructureDefinition): string;
export declare function isExtension(path: string): boolean;
/**
 * Checks if a provided type can be treated as a Reference
 * @param type - The type being checked
 * @returns - True if the type can be treated as a reference, false otherwise
 */
export declare function isReferenceType(type: string): boolean;
