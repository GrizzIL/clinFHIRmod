"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceExporter = void 0;
const fhirtypes_1 = require("../fhirtypes");
const utils_1 = require("../utils");
const common_1 = require("../fhirtypes/common");
const InstanceOfNotDefinedError_1 = require("../errors/InstanceOfNotDefinedError");
const InstanceOfLogicalProfileError_1 = require("../errors/InstanceOfLogicalProfileError");
const lodash_1 = require("lodash");
class InstanceExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    setAssignedValues(fshInstanceDef, instanceDef, instanceOfStructureDefinition) {
        // The fshInstanceDef.rules list may contain insert rules, which will be expanded to AssignmentRules
        common_1.applyInsertRules(fshInstanceDef, this.tank);
        utils_1.resolveSoftIndexing(fshInstanceDef.rules);
        let rules = fshInstanceDef.rules.map(r => lodash_1.cloneDeep(r));
        // Normalize all rules to not use the optional [0] index
        rules.forEach(r => {
            r.path = r.path.replace(/\[0+\]/g, '');
        });
        rules = rules.map(r => common_1.replaceReferences(r, this.tank, this.fisher));
        // Convert strings in AssignmentRules to instances
        rules = rules.filter(r => {
            if (r.isInstance) {
                const instance = this.fishForFHIR(r.value);
                if (instance != null) {
                    r.value = instance;
                    return true;
                }
                else {
                    utils_1.logger.error(`Cannot find definition for Instance: ${r.value}. Skipping rule.`, r.sourceInfo);
                    return false;
                }
            }
            return true;
        });
        // Collect all paths that indicate the sub-paths of that path should be of a given resourceType
        // for example, if a.b = SomePatientInstance, then any subpath (a.b.x) must ensure that when validating
        // Patient is used for the type of a.b
        const inlineResourcePaths = [];
        rules.forEach(r => {
            var _a, _b, _c;
            if (r.isInstance && r.value instanceof fhirtypes_1.InstanceDefinition) {
                inlineResourcePaths.push({
                    path: r.path,
                    // We only use the first element of the meta.profile array, if a need arises for a more
                    // comprehensive approach, we can come back to this later
                    instanceOf: (_c = (_b = (_a = r.value.meta) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : r.value.resourceType
                });
            }
            if (r.path.endsWith('.resourceType') && typeof r.value === 'string') {
                inlineResourcePaths.push({
                    // Only get the part of the path before resourceType, aka if path is a.b.resourceType
                    // the relevant element is a.b, since it is the actual Resource element
                    path: common_1.splitOnPathPeriods(r.path).slice(0, -1).join('.'),
                    instanceOf: r.value
                });
            }
        });
        // When assigning values, things happen in the order:
        // 1 - Validate values for rules that are on the instance
        // 2 - Determine all rules implied by the Structure Definition
        // 3 - Set values from rules implied by the Structure Definition
        // 4 - Set values from rules directly on the instance
        // This order is required due to the fact that validateValueAtPath changes instanceOfStructureDefinition
        // in certain cases that must happen before setting rules from the Structure Definition. In the future
        // we may want to refactor validateValueAtPath, but for now things should happen in this order
        const ruleMap = new Map();
        rules.forEach(rule => {
            try {
                const matchingInlineResourcePaths = inlineResourcePaths.filter(i => rule.path.startsWith(`${i.path}.`) && rule.path !== `${i.path}.resourceType`);
                // Generate an array of resourceTypes that matches the path, so if path is
                // a.b.c.d.e, and b is a Bundle and D is a Patient,
                // inlineResourceTypes = [undefined, "Bundle", undefined, "Patient", undefined]
                const inlineResourceTypes = [];
                matchingInlineResourcePaths.forEach(match => {
                    inlineResourceTypes[common_1.splitOnPathPeriods(match.path).length - 1] = match.instanceOf;
                });
                const validatedRule = instanceOfStructureDefinition.validateValueAtPath(rule.path, rule.value, this.fisher, inlineResourceTypes);
                // Record each valid rule in a map
                ruleMap.set(rule.path, {
                    pathParts: validatedRule.pathParts,
                    assignedValue: validatedRule.assignedValue
                });
            }
            catch (e) {
                utils_1.logger.error(e.message, rule.sourceInfo);
            }
        });
        const paths = ['', ...rules.map(rule => rule.path)];
        // To correctly assign properties, we need to:
        // 1 - Assign implied properties on the original instance
        // 2 - Assign rule properties on a copy of the result of 1, so that rule assignment can build on implied assignment
        // 3 - Merge the result of 2 with the result of 1, so that any implied properties which may have been overwrtiten
        //     in step 2 are maintained...don't worry I'm confused too
        common_1.setImpliedPropertiesOnInstance(instanceDef, instanceOfStructureDefinition, paths, this.fisher);
        const ruleInstance = lodash_1.cloneDeep(instanceDef);
        ruleMap.forEach(rule => common_1.setPropertyOnInstance(ruleInstance, rule.pathParts, rule.assignedValue, this.fisher));
        instanceDef = lodash_1.merge(instanceDef, ruleInstance);
        return instanceDef;
    }
    /**
     * Check that all required elements are present on an InstanceDefinition or
     * a sub-part of an InstanceDefinition for all children of an element.
     * An element is required if it has minimum cardinality greater than 1.
     * @param {{[key: string]: any}} instance - The InstanceDefinition or subsection of an InstanceDefinition we are validating
     * @param {ElementDefinition} element - The element we are trying to validate all children of
     * @param {Instance} fshDefinition - The FSH definition that we built the original InstanceDefinition from
     */
    validateRequiredChildElements(instance, element, fshDefinition) {
        // Get only direct children of the element
        const children = element.children(true);
        children.forEach(c => {
            var _a;
            let child = c;
            // Get the last part of the path, A.B.C => C
            const childPathEnd = child.path.split('.').slice(-1)[0];
            // Note that in most cases the _ prefixed element will not exist. But if it does exist, we validate
            // using the _ prefixed element, since it will contain any children of the primitive
            let instanceChild = (_a = instance[`_${childPathEnd}`]) !== null && _a !== void 0 ? _a : instance[childPathEnd];
            // If the element is a choice, we will fail to find it, we need to use the choice name
            if (instanceChild == null && childPathEnd.endsWith('[x]')) {
                const possibleChoiceSlices = [...children];
                element
                    .findConnectedElements()
                    .forEach(ce => possibleChoiceSlices.push(...ce.children(true)));
                const choiceSlices = possibleChoiceSlices.filter(c => c.path === child.path && c.sliceName);
                for (const choiceSlice of choiceSlices) {
                    instanceChild = instance[choiceSlice.sliceName];
                    if (instanceChild != null) {
                        // Once we find the the choiceSlice that matches, use it as the child
                        child = choiceSlice;
                        break;
                    }
                }
            }
            // Recursively validate children of the current element
            if (Array.isArray(instanceChild)) {
                // If the child is a slice, and there are no array elements with matching slice names
                // but there are array elements that could match (since they use numerical indices)
                // we can go no further in validation, since we can't know which slice is represented
                if (child.sliceName &&
                    !instanceChild.find((arrayEl) => (arrayEl === null || arrayEl === void 0 ? void 0 : arrayEl._sliceName) === child.sliceName) &&
                    instanceChild.find((arrayEl) => !(arrayEl === null || arrayEl === void 0 ? void 0 : arrayEl._sliceName))) {
                    return;
                }
                // Filter so that if the child is a slice, we only count relevant slices
                // A slice is relevant if it is the child slice or is a reslice of child.
                // Typically, a sliceName that starts with child.sliceName + '/' is a reslice.
                instanceChild = instanceChild.filter((arrayEl) => {
                    var _a;
                    return !child.sliceName ||
                        (arrayEl === null || arrayEl === void 0 ? void 0 : arrayEl._sliceName) === child.sliceName || ((_a = arrayEl === null || arrayEl === void 0 ? void 0 : arrayEl._sliceName) === null || _a === void 0 ? void 0 : _a.toString().startsWith(`${child.sliceName}/`));
                });
                instanceChild.forEach((arrayEl) => {
                    if (arrayEl != null)
                        this.validateRequiredChildElements(arrayEl, child, fshDefinition);
                });
            }
            else if (instanceChild != null) {
                this.validateRequiredChildElements(instanceChild, child, fshDefinition);
            }
            // Log an error if:
            // 1 - The child element is 1.., but not on the instance
            // 2 - The child element is n..m, but it has k < n elements
            if ((child.min > 0 && instanceChild == null) ||
                (Array.isArray(instanceChild) && instanceChild.length < child.min)) {
                // Can't point to any specific rule, so give sourceInfo of entire instance
                utils_1.logger.error(`Element ${child.id} has minimum cardinality ${child.min} but occurs ${instanceChild ? instanceChild.length : 0} time(s).`, fshDefinition.sourceInfo);
            }
        });
    }
    /**
     * Check that all required elements are present on an instance
     * @param {InstanceDefinition} instanceDef - The InstanceDefinition we are validating
     * @param {ElementDefinition[]} elements - The elements of the StructDef that instanceDef is an instance of
     * @param {Instance} fshDefinition - The FSH definition that we built instanceDef from
     */
    validateRequiredElements(instanceDef, elements, fshDefinition) {
        this.validateRequiredChildElements(instanceDef, elements[0], fshDefinition);
    }
    shouldSetMetaProfile(instanceDef) {
        var _a;
        switch ((_a = this.tank.config.instanceOptions) === null || _a === void 0 ? void 0 : _a.setMetaProfile) {
            case 'never':
                return false;
            case 'inline-only':
                return instanceDef._instanceMeta.usage === 'Inline';
            case 'standalone-only':
                return instanceDef._instanceMeta.usage !== 'Inline';
            case 'always':
            default:
                return true;
        }
    }
    shouldSetId(instanceDef) {
        var _a;
        switch ((_a = this.tank.config.instanceOptions) === null || _a === void 0 ? void 0 : _a.setId) {
            case 'standalone-only':
                return instanceDef._instanceMeta.usage !== 'Inline';
            case 'always':
            default:
                return true;
        }
    }
    fishForFHIR(item) {
        let result = this.pkg.fish(item, utils_1.Type.Instance);
        if (result == null) {
            // If we find a FSH definition, then we can export and fish for it again
            const fshDefinition = this.tank.fish(item, utils_1.Type.Instance);
            if (fshDefinition) {
                this.exportInstance(fshDefinition);
                result = this.pkg.fish(item, utils_1.Type.Instance);
            }
        }
        return result;
    }
    fishForMetadata(item) {
        // If it's in the tank, it can get the metadata from there (no need to export like in fishForFHIR)
        return this.fisher.fishForMetadata(item, utils_1.Type.Instance);
    }
    exportInstance(fshDefinition) {
        var _a, _b, _c;
        if (this.pkg.instances.some(i => i._instanceMeta.name === fshDefinition.id)) {
            return;
        }
        let isResource = true;
        const json = this.fisher.fishForFHIR(fshDefinition.instanceOf, utils_1.Type.Resource, utils_1.Type.Profile, utils_1.Type.Extension, utils_1.Type.Type);
        if (!json) {
            throw new InstanceOfNotDefinedError_1.InstanceOfNotDefinedError(fshDefinition.name, fshDefinition.instanceOf, fshDefinition.sourceInfo);
        }
        // Since creating an instance of a Logical is not allowed,
        // creating an instance of a Profile of a logical model is also not allowed
        if (json.kind === 'logical' && json.derivation === 'constraint') {
            throw new InstanceOfLogicalProfileError_1.InstanceOfLogicalProfileError(fshDefinition.name, fshDefinition.instanceOf, fshDefinition.sourceInfo);
        }
        if (json.kind !== 'resource') {
            // If the instance is not a resource, it should be inline, since it cannot exist as a standalone instance
            isResource = false;
            if (fshDefinition.usage !== 'Inline') {
                utils_1.logger.warn(`Instance ${fshDefinition.name} is not an instance of a resource, so it should only be used inline on other instances, and it will not be exported to a standalone file. Specify "Usage: #inline" to remove this warning.`, fshDefinition.sourceInfo);
                fshDefinition.usage = 'Inline';
            }
        }
        const instanceOfStructureDefinition = fhirtypes_1.StructureDefinition.fromJSON(json);
        let instanceDef = new fhirtypes_1.InstanceDefinition();
        instanceDef._instanceMeta.name = fshDefinition.id; // This is name of the instance in the FSH
        if (fshDefinition.title) {
            instanceDef._instanceMeta.title = fshDefinition.title;
        }
        if (fshDefinition.description) {
            instanceDef._instanceMeta.description = fshDefinition.description;
        }
        if (fshDefinition.usage) {
            instanceDef._instanceMeta.usage = fshDefinition.usage;
            if (fshDefinition.usage === 'Definition' &&
                instanceOfStructureDefinition.elements.some(element => element.id === `${instanceOfStructureDefinition.type}.url`)) {
                instanceDef.url = `${this.tank.config.canonical}/${instanceOfStructureDefinition.type}/${fshDefinition.id}`;
            }
        }
        if (isResource) {
            instanceDef.resourceType = instanceOfStructureDefinition.type; // ResourceType is determined by the StructureDefinition of the type
            if (this.shouldSetId(instanceDef)) {
                instanceDef.id = fshDefinition.id;
            }
        }
        else {
            instanceDef._instanceMeta.sdType = instanceOfStructureDefinition.type;
        }
        // Set Assigned values based on the FSH rules and the Structure Definition
        instanceDef = this.setAssignedValues(fshDefinition, instanceDef, instanceOfStructureDefinition);
        // should we add the instanceOf to meta.profile?
        // if the exact url is not in there, and a versioned url is also not in there, add it to the front.
        // otherwise, add it at the front.
        if (this.shouldSetMetaProfile(instanceDef) &&
            isResource &&
            instanceOfStructureDefinition.derivation === 'constraint') {
            // elements of instanceDef.meta.profile may be objects if they are provided by slices,
            // since they have to keep track of the _sliceName property.
            // this is technically not a match for the defined type of instanceDef.meta.profile,
            // so give the parameter a union type to handle both cases.
            if (!((_b = (_a = instanceDef.meta) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.some((profile) => {
                const profileUrl = typeof profile === 'object' ? profile.assignedValue : profile;
                return (profileUrl === instanceOfStructureDefinition.url ||
                    profileUrl.startsWith(`${instanceOfStructureDefinition.url}|`));
            }))) {
                // we might have to create meta or meta.profile first, if no rules already created those
                if (instanceDef.meta == null) {
                    instanceDef.meta = { profile: [instanceOfStructureDefinition.url] };
                }
                else if (instanceDef.meta.profile == null) {
                    instanceDef.meta.profile = [instanceOfStructureDefinition.url];
                }
                else {
                    instanceDef.meta.profile.unshift(instanceOfStructureDefinition.url);
                }
            }
        }
        instanceDef.validateId(fshDefinition.sourceInfo);
        this.validateRequiredElements(instanceDef, instanceOfStructureDefinition.elements, fshDefinition);
        common_1.cleanResource(instanceDef);
        this.pkg.instances.push(instanceDef);
        // Once all rules are set, we should ensure that we did not add a duplicate profile URL anywhere
        if ((_c = instanceDef.meta) === null || _c === void 0 ? void 0 : _c.profile)
            instanceDef.meta.profile = lodash_1.uniq(instanceDef.meta.profile);
        // check for another instance of the same type with the same id
        // see https://www.hl7.org/fhir/resource.html#id
        // instanceDef has already been added to the package, so it's fine if it matches itself
        // inline instances are not written to their own files, so those can be skipped in this
        if (instanceDef._instanceMeta.usage !== 'Inline' &&
            this.pkg.instances.some(instance => instance._instanceMeta.usage !== 'Inline' &&
                instanceDef.resourceType === instance.resourceType &&
                instanceDef.id === instance.id &&
                instanceDef !== instance)) {
            utils_1.logger.error(`Multiple instances of type ${instanceDef.resourceType} with id ${instanceDef.id}. Each non-inline instance of a given type must have a unique id.`, fshDefinition.sourceInfo);
        }
        return instanceDef;
    }
    /**
     * Exports Instances
     * @param {FSHTank} tank - The FSH tank we are exporting
     * @returns {Package}
     */
    export() {
        const instances = this.tank.getAllInstances();
        for (const instance of instances) {
            try {
                this.exportInstance(instance);
            }
            catch (e) {
                utils_1.logger.error(e.message, e.sourceInfo);
            }
        }
        if (instances.length > 0) {
            utils_1.logger.info(`Converted ${instances.length} FHIR instances.`);
        }
        return this.pkg;
    }
}
exports.InstanceExporter = InstanceExporter;
//# sourceMappingURL=InstanceExporter.js.map