"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeSystemExporter = void 0;
const fhirtypes_1 = require("../fhirtypes");
const common_1 = require("../fhirtypes/common");
const rules_1 = require("../fshtypes/rules");
const FSHLogger_1 = require("../utils/FSHLogger");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
class CodeSystemExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    setMetadata(codeSystem, fshDefinition) {
        codeSystem.setName(fshDefinition.name, fshDefinition.sourceInfo);
        codeSystem.setId(fshDefinition.id, fshDefinition.sourceInfo);
        if (fshDefinition.title)
            codeSystem.title = fshDefinition.title;
        if (fshDefinition.description)
            codeSystem.description = fshDefinition.description;
        // Version is set to value provided in config, will be overriden if reset by rules
        codeSystem.version = this.tank.config.version;
        codeSystem.url = `${this.tank.config.canonical}/CodeSystem/${codeSystem.id}`;
    }
    setConcepts(codeSystem, concepts) {
        if (concepts.length > 0) {
            codeSystem.concept = [];
            concepts.forEach(concept => {
                let conceptContainer = codeSystem.concept;
                const newConcept = { code: concept.code };
                if (concept.display) {
                    newConcept.display = concept.display;
                }
                if (concept.definition) {
                    newConcept.definition = concept.definition;
                }
                for (const ancestorCode of concept.hierarchy) {
                    const ancestorConcept = conceptContainer.find(ancestorConcept => ancestorConcept.code === ancestorCode);
                    if (ancestorConcept) {
                        if (!ancestorConcept.concept) {
                            ancestorConcept.concept = [];
                        }
                        conceptContainer = ancestorConcept.concept;
                    }
                    else {
                        FSHLogger_1.logger.error(`Could not find ${ancestorCode} in concept hierarchy to use as ancestor of ${concept.code}.`, concept.sourceInfo);
                        return;
                    }
                }
                conceptContainer.push(newConcept);
            });
        }
    }
    setCaretPathRules(codeSystem, csStructureDefinition, rules) {
        // soft index resolution relies on the rule's path attribute.
        // a CaretValueRule is created with an empty path, so first
        // transform its arrayPath into a path.
        // Because this.findConceptPath can potentially throw an error,
        // build a list of successful rules that will actually be applied.
        const successfulRules = [];
        rules.forEach(rule => {
            try {
                rule.path = this.findConceptPath(codeSystem, rule.pathArray);
                successfulRules.push(rule);
                // We can only know that a CaretRule is meant to represent codes
                // after it has been applied on a CodeSystem, so set the flag here
                rule.isCodeCaretRule = true;
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, rule.sourceInfo);
            }
        });
        utils_1.resolveSoftIndexing(successfulRules);
        for (const rule of successfulRules) {
            try {
                const { assignedValue, pathParts } = csStructureDefinition.validateValueAtPath(rule.path.length > 1 ? `${rule.path}.${rule.caretPath}` : rule.caretPath, rule.value, this.fisher);
                common_1.setPropertyOnInstance(codeSystem, pathParts, assignedValue, this.fisher);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, rule.sourceInfo);
            }
        }
    }
    findConceptPath(codeSystem, codePath) {
        var _a, _b;
        const conceptIndices = [];
        let conceptList = (_a = codeSystem.concept) !== null && _a !== void 0 ? _a : [];
        for (const codeStep of codePath) {
            const stepIndex = conceptList.findIndex(concept => concept.code === codeStep);
            if (stepIndex === -1) {
                throw new errors_1.CannotResolvePathError(codePath.map(code => `#${code}`).join(' '));
            }
            conceptIndices.push(stepIndex);
            conceptList = (_b = conceptList[stepIndex].concept) !== null && _b !== void 0 ? _b : [];
        }
        return conceptIndices.map(conceptIndex => `concept[${conceptIndex}]`).join('.');
    }
    countConcepts(concepts) {
        if (concepts) {
            return (concepts.length +
                concepts
                    .map(concept => this.countConcepts(concept.concept))
                    .reduce((sum, next) => sum + next, 0));
        }
        else {
            return 0;
        }
    }
    updateCount(codeSystem, fshDefinition) {
        var _a;
        // We can only derive a true count if the content is #complete
        if (codeSystem.content === 'complete') {
            const actualCount = this.countConcepts(codeSystem.concept) || undefined;
            if (codeSystem.count == null && actualCount != null) {
                codeSystem.count = actualCount;
            }
            else if (codeSystem.count !== actualCount) {
                const countRule = fshDefinition.rules.find(r => r instanceof rules_1.CaretValueRule && r.caretPath === 'count');
                const sourceInfo = (_a = countRule === null || countRule === void 0 ? void 0 : countRule.sourceInfo) !== null && _a !== void 0 ? _a : fshDefinition.sourceInfo;
                FSHLogger_1.logger.warn(`The user-specified ^count (${codeSystem.count}) does not match the specified number of concepts ` +
                    `(${actualCount !== null && actualCount !== void 0 ? actualCount : 0}). If this is not a "complete" CodeSystem, set the ^content property to the appropriate ` +
                    'value; otherwise fix or remove the ^count.', sourceInfo);
            }
        }
    }
    exportCodeSystem(fshDefinition) {
        if (this.pkg.codeSystems.some(cs => cs.name === fshDefinition.name)) {
            return;
        }
        const codeSystem = new fhirtypes_1.CodeSystem();
        this.setMetadata(codeSystem, fshDefinition);
        // fshDefinition.rules may include insert rules, which must be expanded before applying other rules
        common_1.applyInsertRules(fshDefinition, this.tank);
        const csStructureDefinition = fhirtypes_1.StructureDefinition.fromJSON(this.fisher.fishForFHIR('CodeSystem', utils_1.Type.Resource));
        this.setConcepts(codeSystem, fshDefinition.rules.filter(rule => rule instanceof rules_1.ConceptRule));
        this.setCaretPathRules(codeSystem, csStructureDefinition, fshDefinition.rules.filter(rule => rule instanceof rules_1.CaretValueRule));
        // check for another code system with the same id
        // see https://www.hl7.org/fhir/resource.html#id
        if (this.pkg.codeSystems.some(cs => codeSystem.id === cs.id)) {
            FSHLogger_1.logger.error(`Multiple code systems with id ${codeSystem.id}. Each code system must have a unique id.`, fshDefinition.sourceInfo);
        }
        this.updateCount(codeSystem, fshDefinition);
        this.pkg.codeSystems.push(codeSystem);
        return codeSystem;
    }
    export() {
        const codeSystems = this.tank.getAllCodeSystems();
        for (const cs of codeSystems) {
            try {
                this.exportCodeSystem(cs);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, cs.sourceInfo);
            }
        }
        if (codeSystems.length > 0) {
            FSHLogger_1.logger.info(`Converted ${codeSystems.length} FHIR CodeSystems.`);
        }
        return this.pkg;
    }
}
exports.CodeSystemExporter = CodeSystemExporter;
//# sourceMappingURL=CodeSystemExporter.js.map