"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const fhirtypes_1 = require("../fhirtypes");
const errors_1 = require("../errors");
const common_1 = require("../fhirtypes/common");
const lodash_1 = require("lodash");
class MappingExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    /**
     * Sets the mapping on the StructureDefinition
     * @param {StructureDefinition} structDef - The StructureDefinition to set the mapping on
     * @param {Mapping} fshDefinition - The Mapping definition
     * @throws {InvalidFHIRIdError} when the id on the fshDefinition is not valid in FHIR
     */
    setMetadata(structDef, fshDefinition) {
        if (structDef.mapping == null) {
            structDef.mapping = [];
        }
        if (!fhirtypes_1.idRegex.test(fshDefinition.id)) {
            throw new errors_1.InvalidFHIRIdError(fshDefinition.id);
        }
        structDef.mapping.push(Object.assign(Object.assign(Object.assign({ identity: fshDefinition.id }, (fshDefinition.title && { name: fshDefinition.title })), (fshDefinition.target && { uri: fshDefinition.target })), (fshDefinition.description && { comment: fshDefinition.description })));
    }
    /**
     * Applies mapping rules to the individual ElementDefinitions on the SD
     * @param {StructureDefinition} structDef - The StructureDefinition to apply rules on
     * @param {Mapping} fshDefinition - The Mapping definition
     */
    setMappingRules(structDef, fshDefinition) {
        // Before applying mapping rules, applyInsertRules will expand any insert rules into mapping rules
        common_1.applyInsertRules(fshDefinition, this.tank);
        for (const rule of fshDefinition.rules) {
            const element = structDef.findElementByPath(rule.path, this.fisher);
            if (element) {
                try {
                    element.applyMapping(fshDefinition.id, rule.map, rule.comment, rule.language);
                }
                catch (e) {
                    utils_1.logger.error(e.message, rule.sourceInfo);
                }
            }
            else {
                utils_1.logger.error(`No element found at path ${rule.path} for ${fshDefinition.name}, skipping rule`, rule.sourceInfo);
            }
        }
    }
    /**
     * Exports a Mapping by finding the Source StructureDefinition and applying rules
     * @param {Mapping} fshDefinition - The Mapping definition to apply
     */
    exportMapping(fshDefinition) {
        const sourceStructDef = this.pkg.fish(fshDefinition.source, utils_1.Type.Profile, utils_1.Type.Extension);
        if (sourceStructDef) {
            this.setMetadata(sourceStructDef, fshDefinition);
            this.setMappingRules(sourceStructDef, fshDefinition);
        }
        else {
            utils_1.logger.error(`Unable to find source "${fshDefinition.source}".`, fshDefinition.sourceInfo);
        }
    }
    export() {
        const mappings = this.tank.getAllMappings();
        for (const mapping of mappings) {
            try {
                this.exportMapping(mapping);
            }
            catch (e) {
                utils_1.logger.error(e.message, mapping.sourceInfo);
            }
        }
        // The mappings on each Structure Definition should have a unique id
        const groupedMappings = lodash_1.groupBy(mappings, 'source');
        for (const sd in groupedMappings) {
            const duplicateMappings = lodash_1.pickBy(lodash_1.groupBy(groupedMappings[sd], 'id'), m => m.length > 1);
            for (const duplicateId in duplicateMappings) {
                // show error for each time the id was used after the first
                duplicateMappings[duplicateId].slice(1).forEach(m => {
                    utils_1.logger.error(`Multiple mappings on ${sd} found with id ${m.id}`, m.sourceInfo);
                });
            }
        }
    }
}
exports.MappingExporter = MappingExporter;
//# sourceMappingURL=MappingExporter.js.map